import unittest
from RemoteControlApi import ERR_RESOURCE_NOT_FOUND, ERR_CONFIG_PROPERTY_NOT_EXISTING, ERR_HEADER_NOT_IMPLEMENTED, DESTINATION_FILE, \
    ANALYSIS_COMPONENT_PATH, app, guess_config_type, get_password_hash
from fastapi.testclient import TestClient
from database import init_db, SessionLocal, UserDB
from datetime import datetime, timezone
from jsonschema import validate, ValidationError
import os
import json
import asyncio
import threading


def ensure_test_user():
    db = SessionLocal()
    if not db.query(UserDB).filter_by(username="johndoe").first():
        user = UserDB(
            username="johndoe",
            hashed_password=get_password_hash("password"),
            email="john@example.com",
            is_admin=False,
            disabled=False,
            must_reset_password=False,
        )
        db.add(user)
        db.commit()
    db.close()


# def receive_text_with_timeout(ws, timeout=1):
#     result = [None]
#     done = threading.Event()
#     def worker():
#         try:
#             result[0] = ws.receive_text()
#         except Exception:
#             pass
#         finally:
#             done.set()
#     t = threading.Thread(target=worker, daemon=True)
#     t.start()
#     done.wait(timeout)
#     if not done.is_set():
#         try:
#             ws.close()
#         except Exception:
#             pass
#         return None
#     return result[0]


class RemoteControlApiTest(unittest.TestCase):
    """This class tests the REST RemoteControlApi.

    The start of an AMiner instance and of the RemoteControlApi is not
    the task of this class and must be done beforehand.
    """
    client = TestClient(app)
    access_token = None
    token_type = "Bearer"
    authorization_headers = None
    output_schema = {
      "$id": "",
      "title": "Metadata",
      "description": "",
      "$schema": "https://json-schema.org/draft/2020-12/schema",
      "type": "object",
      "properties": {
        "title": {
          "type": "string"
        },
        "creator": {
          "type": "string"
        },
        "subject": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "publisher": {
          "type": "string"
        },
        "contributor": {
          "type": "string"
        },
        "date": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "format": {
          "type": "string"
        },
        "identifier": {
          "type": "string"
        },
        "source": {
          "type": "string"
        },
        "language": {
          "type": "string"
        },
        "relation": {
          "type": "string"
        },
        "coverage": {
          "type": "string"
        },
        "rights": {
          "type": "string"
        }
      },
      "required": [
        "title",
        "creator",
        "subject",
        "description",
        "date",
        "type",
        "format",
        "identifier",
        "language"
      ]
    }

    @classmethod
    def setUpClass(cls):
        init_db()
        ensure_test_user()
        response = cls.client.post("/token", data={
            "username": "johndoe", "password": "password",
            "client_secret": "49e36802e75fdc8d5915073c3b0ed97580be2b701a456e857c6df7a8706a33f9"})
        cls.access_token = json.loads(response.content)["access_token"]
        cls.authorization_headers = {"Authorization": "%s %s" % (cls.token_type, cls.access_token)}

        response = cls.client.get("/", headers=cls.authorization_headers)
        cls.dest_config_file = DESTINATION_FILE + guess_config_type(response.content.split(b":", 1)[1].strip(b" ").strip(b"\n").strip(b"'").decode("unicode-escape"))

    def test0websocket_aminer_output(self):
        """Test that WebSocket endpoint broadcasts new file lines."""
        response = self.client.post("/aminer-input", json={"log_id": "1", "timestamp": str(datetime.now(timezone.utc).timestamp()), "severity": "info", "source": "remoteControlApiTest", "message": "initial line"})
        self.assertEqual(response.status_code, 200)
        data = json.loads(response.content.decode())
        validate(instance=data, schema=self.output_schema)
        response = self.client.post("/aminer-input", json={"log_id": "2", "timestamp": str(datetime.now(timezone.utc).timestamp()), "severity": "info", "source": "remoteControlApiTest", "message": "new json output line"})
        data = json.loads(response.content.decode())
        validate(instance=data, schema=self.output_schema)
        self.assertEqual(response.status_code, 200)

    def test1get_config_property(self):
        live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        property_name = "MailAlerting.MaxEventsPerMessage"
        response = self.client.get("config_property/%s" % property_name, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f"{{\"{property_name}\":1000}}".encode())
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        self.assertEqual(new_live_config, live_config)

        live_config = new_live_config
        property_name = "AminerUser"
        response = self.client.get("config_property/%s" % property_name, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f"{{\"{property_name}\":\"aminer\"}}".encode())
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        self.assertEqual(new_live_config, live_config)

        live_config = new_live_config
        property_name = "LogResourceList"
        response = self.client.get("config_property/%s" % property_name, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f"{{\"{property_name}\":[\"file:///tmp/syslog\",\"file:///tmp/aminer-rest-input.log\"]}}".encode())
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        self.assertEqual(new_live_config, live_config)

        live_config = new_live_config
        response = self.client.get("config_property/%s" % property_name)
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        self.assertEqual(new_live_config, live_config)

        live_config = new_live_config
        response = self.client.get("config_property/%s" % property_name, headers={
            "Authorization": "%s %s" % (self.token_type, self.access_token + "failedtoken")})
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        self.assertEqual(new_live_config, live_config)

        live_config = new_live_config
        property_name = "NonExistentConfigProperty"
        response = self.client.get("config_property/%s" % property_name, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f"{{\"ErrorMessage\":{ERR_RESOURCE_NOT_FOUND.decode() % property_name}}}".encode())
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        self.assertEqual(new_live_config, live_config)

    def test2put_config_property(self):
        contentpy = b'"Remote execution response: \'from aminer.parsing.FirstMatchModelElement import FirstMatchModelElement\\nfrom aminer.parsing.SequenceModelElement import SequenceModelElement\\nfrom aminer.parsing.FixedDataModelElement import FixedDataModelElement\\nfrom aminer.parsing.DelimitedDataModelElement import DelimitedDataModelElement\\nfrom aminer.parsing.AnyByteDataModelElement import AnyByteDataModelElement\\nfrom aminer.parsing.FixedWordlistDataModelElement import FixedWordlistDataModelElement\\nfrom aminer.parsing.DecimalIntegerValueModelElement import DecimalIntegerValueModelElement\\nfrom aminer.parsing.DateTimeModelElement import DateTimeModelElement\\nfrom aminer.parsing.IpAddressDataModelElement import IpAddressDataModelElement\\nfrom aminer.parsing.OptionalMatchModelElement import OptionalMatchModelElement\\n\\n# This is a template for the \\"aminer\\" logfile miner tool. Copy\\n# it to \\"config.py\\" and define your ruleset.\\n\\nconfig_properties = {}\\n\\n# Define the list of log resources to read from: the resources\\n# named here do not need to exist when aminer is started. This\\n# will just result in a warning. However, if they exist, they have\\n# to be readable by the aminer process! Supported types are:\\n# * file://[path]: Read data from file, reopen it after rollover\\n# * unix://[path]: Open the path as UNIX local socket for reading\\n\\n# can not use unix socket for aminer-rest, because the socket needs to be open, while aminer-rest needs aminer running at startup.\\nconfig_properties[\'LogResourceList\'] = [\'file:///tmp/syslog\', \'file:///tmp/aminer-rest-input.log\']\\n\\n# Define the uid/gid of the process that runs the calculation\\n# after opening the log files:\\nconfig_properties[\'AminerUser\'] = \'aminer\'\\nconfig_properties[\'AminerGroup\'] = \'aminer\'\\n\\n# Define the path, where aminer will listen for incoming remote\\n# control connections. When missing, no remote control socket\\n# will be created.\\nconfig_properties[\'RemoteControlSocket\'] = \'/var/run/aminer-remote.socket\'\\n\\n# Read the analyis from this file. That part of configuration\\n# is separated from the main configuration so that it can be loaded\\n# only within the analysis child. Non-absolute path names are\\n# interpreted relatively to the main configuration file (this\\n# file). When empty, this configuration has to contain the configuration\\n# for the child also.\\n# config_properties[\'AnalysisConfigFile\'] = \'analysis.py\'\\n\\nconfig_properties[\'Core.LogDir\'] = \'/tmp/lib/aminer/log\'\\n# Read and store information to be used between multiple invocations\\n# of aminer in this directory. The directory must only be accessible\\n# to the \'AminerUser\' but not group/world readable. On violation,\\n# aminer will refuse to start. When undefined, \'/var/lib/aminer\'\\n# is used.\\nconfig_properties[\'Core.PersistenceDir\'] = \'/tmp/lib/aminer\'\\n\\n# Define a target e-mail address to send alerts to. When undefined,\\n# no e-mail notification hooks are added.\\nconfig_properties[\'MailAlerting.TargetAddress\'] = \'root@localhost\'\\n# Sender address of e-mail alerts. When undefined, \\"sendmail\\"\\n# implementation on host will decide, which sender address should\\n# be used.\\nconfig_properties[\'MailAlerting.FromAddress\'] = \'root@localhost\'\\n# Define, which text should be prepended to the standard aminer\\n# subject. Defaults to \\"aminer Alerts:\\"\\nconfig_properties[\'MailAlerting.SubjectPrefix\'] = \'aminer Alerts:\'\\n# Define a grace time after startup before aminer will react to\\n# an event and send the first alert e-mail. Defaults to 0 (any\\n# event can immediately trigger alerting).\\nconfig_properties[\'MailAlerting.AlertGraceTime\'] = 0\\n# Define how many seconds to wait after a first event triggered\\n# the alerting procedure before really sending out the e-mail.\\n# In that timespan, events are collected and will be sent all\\n# using a single e-mail. Defaults to 10 seconds.\\nconfig_properties[\'MailAlerting.EventCollectTime\'] = 0\\n# Define the minimum time between two alert e-mails in seconds\\n# to avoid spamming. All events during this timespan are collected\\n# and sent out with the next report. Defaults to 600 seconds.\\nconfig_properties[\'MailAlerting.MinAlertGap\'] = 0\\n# Define the maximum time between two alert e-mails in seconds.\\n# When undefined this defaults to \\"MailAlerting.MinAlertGap\\".\\n# Otherwise this will activate an exponential backoff to reduce\\n# messages during permanent error states by increasing the alert\\n# gap by 50% when more alert-worthy events were recorded while\\n# the previous gap time was not yet elapsed.\\nconfig_properties[\'MailAlerting.MaxAlertGap\'] = 600\\n# Define how many events should be included in one alert mail\\n# at most. This defaults to 1000\\nconfig_properties[\'MailAlerting.MaxEventsPerMessage\'] = 1000\\nconfig_properties[\'LogPrefix\'] = \'Original log line: \'\\n\\n# Add your ruleset here:\\n\\n\\ndef build_analysis_pipeline(analysis_context):\\n    \\"\\"\\"Define the function to create pipeline for parsing the log data.\\n\\n    It has also to define an AtomizerFactory to instruct aminer how to\\n    process incoming data streams to create log atoms from them.\\n    \\"\\"\\"\\n    # Build the parsing model:\\n\\n    service_children_disk_report = [\\n        FixedDataModelElement(\'Space\', b\' Current Disk Data is: Filesystem     Type  Size  Used Avail Use%\'),\\n        DelimitedDataModelElement(\'Data\', b\'%\'), AnyByteDataModelElement(\'Rest\')]\\n\\n    service_children_login_details = [\\n        FixedDataModelElement(\'User\', b\'User \'), DelimitedDataModelElement(\'Username\', b\' \'),\\n        FixedWordlistDataModelElement(\'Status\', [b\' logged in\', b\' logged out\']),\\n        OptionalMatchModelElement(\'PastTime\', SequenceModelElement(\'Time\', [\\n            FixedDataModelElement(\'Blank\', b\' \'), DecimalIntegerValueModelElement(\'Minutes\'),\\n            FixedDataModelElement(\'Ago\', b\' minutes ago.\')]))]\\n\\n    service_children_cron_job = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'UNameSpace1\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'UNameSpace2\', b\' \'), DelimitedDataModelElement(\'User\', b\' \'),\\n        FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Details\', b\']: Job `cron.daily` started.\')]\\n\\n    service_children_random_time = [FixedDataModelElement(\'Space\', b\'Random: \'), DecimalIntegerValueModelElement(\'Random\')]\\n\\n    service_children_sensors = [SequenceModelElement(\'CPUTemp\', [\\n        FixedDataModelElement(\'FixedTemp\', b\'CPU Temp: \'), DecimalIntegerValueModelElement(\'Temp\'),\\n        FixedDataModelElement(\'Degrees\', b\'\\\\xc2\\\\xb0C\')]), FixedDataModelElement(\'Space1\', b\', \'), SequenceModelElement(\'CPUWorkload\', [\\n            FixedDataModelElement(\'FixedWorkload\', b\'CPUWorkload: \'), DecimalIntegerValueModelElement(\'Workload\'),\\n            FixedDataModelElement(\'Percent\', b\'%\')]), FixedDataModelElement(\'Space2\', b\', \'),\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\')]\\n\\n    service_children_user_ip_address = [\\n        FixedDataModelElement(\'User\', b\'User \'), DelimitedDataModelElement(\'Username\', b\' \'),\\n        FixedDataModelElement(\'Action\', b\' changed IP address to \'), IpAddressDataModelElement(\'IP\')]\\n\\n    service_children_cron_job_announcement = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'Space\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Run\', b\']: Will run job `\'),\\n        FixedWordlistDataModelElement(\'CronType\', [b\'cron.daily\', b\'cron.hourly\', b\'cron.monthly\', b\'cron.weekly\']),\\n        FixedDataModelElement(\'StartTime\', b\'\\\\\' in 5 min.\')]\\n\\n    service_children_cron_job_execution = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'Space1\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Job\', b\']: Job `\'),\\n        FixedWordlistDataModelElement(\'CronType\', [b\'cron.daily\', b\'cron.hourly\', b\'cron.monthly\', b\'cron.weekly\']),\\n        FixedDataModelElement(\'Started\', b\'\\\\\' started\')]\\n\\n    parsing_model = FirstMatchModelElement(\'model\', [\\n        SequenceModelElement(\'CronAnnouncement\', service_children_cron_job_announcement),\\n        SequenceModelElement(\'CronExecution\', service_children_cron_job_execution),\\n        SequenceModelElement(\'DailyCron\', service_children_cron_job), SequenceModelElement(\'DiskReport\', service_children_disk_report),\\n        SequenceModelElement(\'LoginDetails\', service_children_login_details), DecimalIntegerValueModelElement(\'Random\'),\\n        SequenceModelElement(\'RandomTime\', service_children_random_time), SequenceModelElement(\'Sensors\', service_children_sensors),\\n        SequenceModelElement(\'IPAddresses\', service_children_user_ip_address)])\\n\\n    # Some generic imports.\\n    from aminer.analysis import AtomFilters\\n\\n    # Create all global handler lists here and append the real handlers later on.\\n    # Use this filter to distribute all atoms to the analysis handlers.\\n    atom_filters = AtomFilters.SubhandlerFilter(None)\\n    analysis_context.register_component(atom_filters, component_name=\\"AtomFilter\\")\\n\\n    from aminer.analysis.TimestampCorrectionFilters import SimpleMonotonicTimestampAdjust\\n    simple_monotonic_timestamp_adjust = SimpleMonotonicTimestampAdjust([atom_filters])\\n    analysis_context.register_component(simple_monotonic_timestamp_adjust, component_name=\\"SimpleMonotonicTimestampAdjust\\")\\n\\n    from aminer.events.StreamPrinterEventHandler import StreamPrinterEventHandler\\n    import os\\n    import stat\\n    stpe = StreamPrinterEventHandler(analysis_context)\\n    aminer_rest_output = "/tmp/aminer-rest-output.log"\\n    mode = \'w+\'\\n    if os.path.exists(aminer_rest_output) and stat.S_ISFIFO(os.stat(aminer_rest_output).st_mode):\\n        mode = \'w\'\\n    stream = open(aminer_rest_output, mode)\\n    aminer_rest_stpe = StreamPrinterEventHandler(analysis_context, stream)\\n    from aminer.events.JsonConverterHandler import JsonConverterHandler\\n    aminer_rest_jch = JsonConverterHandler([aminer_rest_stpe], analysis_context, pretty_print=False)\\n\\n    from aminer.events.Utils import VolatileLogarithmicBackoffEventHistory\\n    volatile_logarithmic_backoff_event_history = VolatileLogarithmicBackoffEventHistory(100)\\n    anomaly_event_handlers = [stpe, aminer_rest_jch, volatile_logarithmic_backoff_event_history]\\n    analysis_context.register_component(volatile_logarithmic_backoff_event_history, component_name=\\"VolatileLogarithmicBackoffEventHistory\\")\\n\\n    # Now define the AtomizerFactory using the model. A simple line based one is usually sufficient.\\n    from aminer.input.SimpleByteStreamLineAtomizerFactory import SimpleByteStreamLineAtomizerFactory\\n    analysis_context.atomizer_factory = SimpleByteStreamLineAtomizerFactory(\\n        parsing_model, [simple_monotonic_timestamp_adjust], anomaly_event_handlers, use_real_time=True)\\n\\n    # Just report all unparsed atoms to the event handlers.\\n    from aminer.analysis.UnparsedAtomHandlers import SimpleUnparsedAtomHandler\\n    simple_unparsed_atom_handler = SimpleUnparsedAtomHandler(anomaly_event_handlers)\\n    atom_filters.add_handler(simple_unparsed_atom_handler, stop_when_handled_flag=True)\\n    analysis_context.register_component(simple_unparsed_atom_handler, component_name=\\"UnparsedHandler\\")\\n\\n    from aminer.analysis.TimestampsUnsortedDetector import TimestampsUnsortedDetector\\n    timestamps_unsorted_detector = TimestampsUnsortedDetector(analysis_context.aminer_config, anomaly_event_handlers)\\n    atom_filters.add_handler(timestamps_unsorted_detector)\\n    analysis_context.register_component(timestamps_unsorted_detector, component_name=\\"TimestampsUnsortedDetector\\")\\n\\n    from aminer.analysis import Rules\\n    from aminer.analysis.AllowlistViolationDetector import AllowlistViolationDetector\\n    allowlist_rules = [\\n        Rules.OrMatchRule([\\n            Rules.AndMatchRule([\\n                Rules.PathExistsMatchRule(\'/model/LoginDetails/PastTime/Time/Minutes\'),\\n                Rules.NegationMatchRule(Rules.ValueMatchRule(\'/model/LoginDetails/Username\', b\'root\'))]),\\n            Rules.AndMatchRule([\\n                Rules.NegationMatchRule(Rules.PathExistsMatchRule(\'/model/LoginDetails/PastTime/Time/Minutes\')),\\n                Rules.PathExistsMatchRule(\'/model/LoginDetails\')]),\\n            Rules.NegationMatchRule(Rules.PathExistsMatchRule(\'/model/LoginDetails\'))])]\\n\\n    # This rule list should trigger, when the line does not look like: User root (logged in, logged out)\\n    # or User \'username\' (logged in, logged out) x minutes ago.\\n    allowlist_violation_detector = AllowlistViolationDetector(analysis_context.aminer_config, allowlist_rules, anomaly_event_handlers)\\n    analysis_context.register_component(allowlist_violation_detector, component_name=\\"Allowlist\\")\\n    atom_filters.add_handler(allowlist_violation_detector)\\n\\n    from aminer.analysis.ParserCount import ParserCount\\n    parser_count = ParserCount(analysis_context.aminer_config, None, anomaly_event_handlers, 10)\\n    analysis_context.register_component(parser_count, component_name=\\"ParserCount\\")\\n    atom_filters.add_handler(parser_count)\\n\\n    from aminer.analysis.EventCorrelationDetector import EventCorrelationDetector\\n    ecd = EventCorrelationDetector(analysis_context.aminer_config, anomaly_event_handlers, check_rules_flag=True,\\n                                   hypothesis_max_delta_time=1.0, learn_mode=True)\\n    analysis_context.register_component(ecd, component_name=\\"EventCorrelationDetector\\")\\n    atom_filters.add_handler(ecd)\\n\\n    from aminer.analysis.NewMatchPathDetector import NewMatchPathDetector\\n    new_match_path_detector = NewMatchPathDetector(analysis_context.aminer_config, anomaly_event_handlers, learn_mode=True)\\n    analysis_context.register_component(new_match_path_detector, component_name=\\"NewMatchPath\\")\\n    atom_filters.add_handler(new_match_path_detector)\\n\\n    def tuple_transformation_function(match_value_list):\\n        \\"\\"\\"Only allow output of the EnhancedNewMatchPathValueComboDetector\\n        after every 10000th element.\\"\\"\\"\\n        extra_data = enhanced_new_match_path_value_combo_detector.known_values_dict.get(tuple(match_value_list))\\n        if extra_data is not None:\\n            mod = 10000\\n            if (extra_data[2] + 1) % mod == 0:\\n                enhanced_new_match_path_value_combo_detector.learn_mode = False\\n            else:\\n                enhanced_new_match_path_value_combo_detector.learn_mode = True\\n        return match_value_list\\n\\n    from aminer.analysis.EnhancedNewMatchPathValueComboDetector import EnhancedNewMatchPathValueComboDetector\\n    enhanced_new_match_path_value_combo_detector = EnhancedNewMatchPathValueComboDetector(\\n        analysis_context.aminer_config, [\'/model/DailyCron/UName\', \'/model/DailyCron/JobNumber\'], anomaly_event_handlers,\\n        learn_mode=False, tuple_transformation_function=tuple_transformation_function)\\n    analysis_context.register_component(enhanced_new_match_path_value_combo_detector, component_name=\\"EnhancedNewValueCombo\\")\\n    atom_filters.add_handler(enhanced_new_match_path_value_combo_detector)\\n\\n    from aminer.analysis.HistogramAnalysis import HistogramAnalysis, LinearNumericBinDefinition, ModuloTimeBinDefinition, \\\\\\n        PathDependentHistogramAnalysis\\n    modulo_time_bin_definition = ModuloTimeBinDefinition(86400, 3600, 0, 1, 24, True)\\n    linear_numeric_bin_definition = LinearNumericBinDefinition(50, 5, 20, True)\\n    histogram_analysis = HistogramAnalysis(analysis_context.aminer_config, [\\n        (\'/model/RandomTime/Random\', modulo_time_bin_definition), (\'/model/Random\', linear_numeric_bin_definition)], 10,\\n        anomaly_event_handlers)\\n    analysis_context.register_component(histogram_analysis, component_name=\\"HistogramAnalysis\\")\\n    atom_filters.add_handler(histogram_analysis)\\n\\n    path_dependent_histogram_analysis = PathDependentHistogramAnalysis(analysis_context.aminer_config, \'/model/RandomTime\',\\n                                                                       modulo_time_bin_definition, 10, anomaly_event_handlers)\\n    analysis_context.register_component(path_dependent_histogram_analysis, component_name=\\"PathDependentHistogramAnalysis\\")\\n    atom_filters.add_handler(path_dependent_histogram_analysis)\\n\\n    from aminer.analysis.MatchValueAverageChangeDetector import MatchValueAverageChangeDetector\\n    match_value_average_change_detector = MatchValueAverageChangeDetector(analysis_context.aminer_config, anomaly_event_handlers, None,\\n                                                                          [\'/model/Random\'], 100, 10)\\n    analysis_context.register_component(match_value_average_change_detector, component_name=\\"MatchValueAverageChange\\")\\n    atom_filters.add_handler(match_value_average_change_detector)\\n\\n    import sys\\n    from aminer.analysis.MatchValueStreamWriter import MatchValueStreamWriter\\n    match_value_stream_writer = MatchValueStreamWriter(\\n        sys.stdout, [\'/model/Sensors/CPUTemp\', \'/model/Sensors/CPUWorkload\', \'/model/Sensors/DTM\'], b\';\', b\'\')\\n    analysis_context.register_component(match_value_stream_writer, component_name=\\"MatchValueStreamWriter\\")\\n    atom_filters.add_handler(match_value_stream_writer)\\n\\n    from aminer.analysis.NewMatchPathValueComboDetector import NewMatchPathValueComboDetector\\n    new_match_path_value_combo_detector = NewMatchPathValueComboDetector(analysis_context.aminer_config, [\\n        \'/model/IPAddresses/Username\', \'/model/IPAddresses/IP\'], anomaly_event_handlers, learn_mode=False)\\n    analysis_context.register_component(new_match_path_value_combo_detector, component_name=\\"NewMatchPathValueCombo\\")\\n    atom_filters.add_handler(new_match_path_value_combo_detector)\\n\\n    from aminer.analysis.NewMatchIdValueComboDetector import NewMatchIdValueComboDetector\\n    new_match_id_value_combo_detector = NewMatchIdValueComboDetector(\\n        analysis_context.aminer_config, [\'/model/type/path/id\', \'/model/type/syscall/id\'], anomaly_event_handlers,\\n        id_path_list=[\'/model/type/path/id\', \'/model/type/syscall/id\'], min_allowed_time_diff=5, learn_mode=True,\\n        allow_missing_values_flag=True, output_logline=True)\\n    analysis_context.register_component(new_match_id_value_combo_detector, component_name=\\"NewMatchIdValueComboDetector\\")\\n    atom_filters.add_handler(new_match_id_value_combo_detector)\\n\\n    from aminer.analysis.NewMatchPathValueDetector import NewMatchPathValueDetector\\n    new_match_path_value_detector = NewMatchPathValueDetector(analysis_context.aminer_config, [\\n        \'/model/DailyCron/Job Number\', \'/model/IPAddresses/Username\'], anomaly_event_handlers, learn_mode=False)\\n    analysis_context.register_component(new_match_path_value_detector, component_name=\\"NewMatchPathValue\\")\\n    atom_filters.add_handler(new_match_path_value_detector)\\n\\n    from aminer.analysis.MissingMatchPathValueDetector import MissingMatchPathValueDetector\\n    missing_match_path_value_detector = MissingMatchPathValueDetector(\\n        analysis_context.aminer_config, [\'/model/DiskReport/Space\'], anomaly_event_handlers, learn_mode=False, default_interval=2,\\n        realert_interval=5)\\n    analysis_context.register_component(missing_match_path_value_detector, component_name=\\"MissingMatch\\")\\n    atom_filters.add_handler(missing_match_path_value_detector)\\n\\n    from aminer.analysis.TimeCorrelationDetector import TimeCorrelationDetector\\n    time_correlation_detector = TimeCorrelationDetector(\\n        analysis_context.aminer_config, anomaly_event_handlers, 2, min_rule_attributes=1, max_rule_attributes=5,\\n        record_count_before_event=70000, output_logline=True)\\n    analysis_context.register_component(time_correlation_detector, component_name=\\"TimeCorrelationDetector\\")\\n    atom_filters.add_handler(time_correlation_detector)\\n\\n    from aminer.analysis.TimeCorrelationViolationDetector import TimeCorrelationViolationDetector, CorrelationRule, EventClassSelector\\n    cron_job_announcement = CorrelationRule(\'CronJobAnnouncement\', 5, 6, artefact_match_parameters=[\\n        (\'/model/CronAnnouncement/JobNumber\', \'/model/CronExecution/JobNumber\')])\\n    a_class_selector = EventClassSelector(\'Announcement\', [cron_job_announcement], None)\\n    b_class_selector = EventClassSelector(\'Execution\', None, [cron_job_announcement])\\n    rules = [Rules.PathExistsMatchRule(\'/model/CronAnnouncement/Run\', a_class_selector),\\n             Rules.PathExistsMatchRule(\'/model/CronExecution/Job\', b_class_selector)]\\n\\n    time_correlation_violation_detector = TimeCorrelationViolationDetector(analysis_context.aminer_config, rules, anomaly_event_handlers)\\n    analysis_context.register_component(time_correlation_violation_detector, component_name=\\"TimeCorrelationViolationDetector\\")\\n    atom_filters.add_handler(time_correlation_violation_detector)\\n\\n    from aminer.events.DefaultMailNotificationEventHandler import DefaultMailNotificationEventHandler\\n    if DefaultMailNotificationEventHandler.CONFIG_KEY_MAIL_TARGET_ADDRESS in analysis_context.aminer_config.config_properties:\\n        mail_notification_handler = DefaultMailNotificationEventHandler(analysis_context)\\n        analysis_context.register_component(mail_notification_handler, component_name=\\"MailHandler\\")\\n        anomaly_event_handlers.append(mail_notification_handler)\\n\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600\'"'
        contentyml = b'"Remote execution response: \'LearnMode: False\\n\\nCore.LogDir: \'/tmp/lib/aminer/log\'\\n\\nCore.PersistenceDir: \'/tmp/lib/aminer\'\\n\\nCore.PersistencePeriod: 600\\n\\n# can not use unix socket for aminer-rest, because the socket needs to be open, while aminer-rest needs aminer running at startup.\\nLogResourceList:\\n        - \'file:///tmp/syslog\'\\n        - \'file:///tmp/aminer-rest-input.log\'\\n\\nRemoteControlSocket: \'/var/run/aminer-remote.socket\'\\n\\nMailAlerting.TargetAddress: \'root@localhost\'\\n\\nMailAlerting.FromAddress: \'root@localhost\'\\n\\nMailAlerting.SubjectPrefix: \'aminer Alerts:\'\\n\\nMailAlerting.AlertGraceTime: 0\\n\\nMailAlerting.EventCollectTime: 0\\n\\nMailAlerting.MinAlertGap: 0\\n\\nMailAlerting.MaxAlertGap: 600\\n\\nMailAlerting.MaxEventsPerMessage: 1000\\n\\nLogPrefix: \'Original log line: \'\\n\\nAminerId: \'demo-aminer\'\\n\\nParser:\\n       - id: space\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \' Current Disk Data is: Filesystem     Type  Size  Used Avail Use%\'\\n\\n       - id: data\\n         type: DelimitedDataModelElement\\n         name: \'Data\'\\n         delimiter: \'%\'\'/\'\\n\\n       - id: rest\\n         type: AnyByteDataModelElement\\n         name: \'Rest\'\\n\\n       - id: userLoginDetails\\n         type: FixedDataModelElement\\n         name: \'User\'\\n         args: \'User \'\\n\\n       - id: userIpAddress\\n         type: FixedDataModelElement\\n         name: \'User\'\\n         args: \'User \'\\n\\n       - id: username\\n         type: DelimitedDataModelElement\\n         name: \'Username\'\\n         delimiter: \' \'\\n\\n       - id: status\\n         type: FixedWordlistDataModelElement\\n         name: \'Status\'\\n         args:\\n           - \' logged in\'\\n           - \' logged out\'\\n\\n       - id: blank\\n         type: FixedDataModelElement\\n         name: \'Blank\'\\n         args: \' \'\\n\\n       - id: minutes\\n         type: DecimalIntegerValueModelElement\\n         name: \'Minutes\'\\n\\n       - id: ago\\n         type: FixedDataModelElement\\n         name: \'Ago\'\\n         args: \' minutes ago.\'\\n\\n       - id: time\\n         type: SequenceModelElement\\n         name: \'Time\'\\n         args:\\n           - blank\\n           - minutes\\n           - ago\\n\\n       - id: pastTime\\n         type: OptionalMatchModelElement\\n         name: \'PastTime\'\\n         args: time\\n\\n       - id: dtm\\n         type: DateTimeModelElement\\n         name: \'DTM\'\\n         date_format: \'%Y-%m-%d %H:%M:%S\'\\n         start_year: null\\n         text_locale: null\\n         max_time_jump_seconds: 86400\\n\\n       - id: uNameSpace1\\n         type: FixedDataModelElement\\n         name: \'UNameSpace1\'\\n         args: \' \'\\n\\n       - id: uName\\n         type: DelimitedDataModelElement\\n         name: \'UName\'\\n         delimiter: \' \'\\n\\n       - id: uNameSpace2\\n         type: FixedDataModelElement\\n         name: \'UNameSpace2\'\\n         args: \' \'\\n\\n       - id: delimitedUser\\n         type: DelimitedDataModelElement\\n         name: \'User\'\\n         delimiter: \' \'\\n\\n       - id: cron\\n         type: FixedDataModelElement\\n         name: \'Cron\'\\n         args: \' cron[\'\\n\\n       - id: jobNumber\\n         type: DecimalIntegerValueModelElement\\n         name: \'JobNumber\'\\n\\n       - id: details\\n         type: FixedDataModelElement\\n         name: \'Details\'\\n         args: \']: Job `cron.daily` started.\'\\n\\n       - id: spaceRandom\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \'Random: \'\\n\\n       - id: random\\n         type: DecimalIntegerValueModelElement\\n         name: \'Random\'\\n\\n       - id: fixedTemp\\n         type: FixedDataModelElement\\n         name: \'FixedTemp\'\\n         args: \'CPU Temp: \'\\n\\n       - id: temp\\n         type: DecimalIntegerValueModelElement\\n         name: \'Temp\'\\n\\n       - id: degrees\\n         type: FixedDataModelElement\\n         name: \'Degrees\'\\n         args: \'\xc2\xb0C\'\\n\\n       - id: cpuTemp\\n         type: SequenceModelElement\\n         name: \'CPUTemp\'\\n         args:\\n           - fixedTemp\\n           - temp\\n           - degrees\\n\\n       - id: space1\\n         type: FixedDataModelElement\\n         name: \'Space1\'\\n         args: \', \'\\n\\n       - id: fixedWorkload\\n         type: FixedDataModelElement\\n         name: \'FixedWorkload\'\\n         args: \'CPU Workload: \'\\n\\n       - id: workload\\n         type: DecimalIntegerValueModelElement\\n         name: \'Workload\'\\n\\n       - id: percent\\n         type: FixedDataModelElement\\n         name: \'Percent\'\\n         args: \'%\'\\n\\n       - id: cpuWorkload\\n         type: SequenceModelElement\\n         name: \'CPUWorkload\'\\n         args:\\n           - fixedWorkload\\n           - workload\\n           - percent\\n\\n       - id: space2\\n         type: FixedDataModelElement\\n         name: \'Space2\'\\n         args: \', \'\\n\\n       - id: action\\n         type: FixedDataModelElement\\n         name: \'Action\'\\n         args: \' changed IP address to \'\\n\\n       - id: ip\\n         type: IpAddressDataModelElement\\n         name: \'IP\'\\n\\n       - id: fixedSpace\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \' \'\\n\\n       - id: run\\n         type: FixedDataModelElement\\n         name: \'Run\'\\n         args: \']: Will run job `\'\\n\\n       - id: cronType\\n         type: FixedWordlistDataModelElement\\n         name: \'CronType\'\\n         args:\\n           - \'cron.daily\'\\n           - \'cron.hourly\'\\n           - \'cron.monthly\'\\n           - \'cron.weekly\'\\n\\n       - id: startTime\\n         type: FixedDataModelElement\\n         name: \'StartTime\'\\n         args: \\"\' in 5 min.\\"\\n\\n       - id: emptySpace1\\n         type: FixedDataModelElement\\n         name: \'Space1\'\\n         args: \' \'\\n\\n       - id: job\\n         type: FixedDataModelElement\\n         name: \'Job\'\\n         args: \']: Job `\'\\n\\n       - id: started\\n         type: FixedDataModelElement\\n         name: \'Started\'\\n         args: \\"\' started\\"\\n\\n       - id: cronAnnouncement\\n         type: SequenceModelElement\\n         name: \'CronAnnouncement\'\\n         args:\\n           - dtm\\n           - fixedSpace\\n           - uName\\n           - cron\\n           - jobNumber\\n           - run\\n           - cronType\\n           - startTime\\n\\n       - id: cronExecution\\n         type: SequenceModelElement\\n         name: \'CronExecution\'\\n         args:\\n           - dtm\\n           - emptySpace1\\n           - uName\\n           - cron\\n           - jobNumber\\n           - job\\n           - cronType\\n           - started\\n\\n       - id: dailyCron\\n         type: SequenceModelElement\\n         name: \'DailyCron\'\\n         args:\\n           - dtm\\n           - uNameSpace1\\n           - uName\\n           - uNameSpace2\\n           - delimitedUser\\n           - cron\\n           - jobNumber\\n           - details\\n\\n       - id: diskReport\\n         type: SequenceModelElement\\n         name: \'DiskReport\'\\n         args:\\n           - space\\n           - data\\n           - rest\\n\\n       - id: loginDetails\\n         type: SequenceModelElement\\n         name: \'LoginDetails\'\\n         args:\\n           - userLoginDetails\\n           - username\\n           - status\\n           - pastTime\\n\\n       - id: randomTime\\n         type: SequenceModelElement\\n         name: \'RandomTime\'\\n         args:\\n           - spaceRandom\\n           - random\\n\\n       - id: sensors\\n         type: SequenceModelElement\\n         name: \'Sensors\'\\n         args:\\n           - cpuTemp\\n           - space1\\n           - cpuWorkload\\n           - space2\\n           - dtm\\n\\n       - id: ipAddresses\\n         type: SequenceModelElement\\n         name: \'IPAddresses\'\\n         args:\\n           - userIpAddress\\n           - username\\n           - action\\n           - ip\\n\\n       - id: model\\n         start: True\\n         type: FirstMatchModelElement\\n         name: \'model\'\\n         args:\\n           - cronAnnouncement\\n           - cronExecution\\n           - dailyCron\\n           - diskReport\\n           - loginDetails\\n           - random\\n           - randomTime\\n           - sensors\\n           - ipAddresses\\n\\nInput:\\n        timestamp_paths: [\\"/model/DailyCron/DTM\\"]\\n        adjust_timestamps: True\\n        use_real_time: True\\n\\nAnalysis:\\n        - type: TimestampsUnsortedDetector\\n          id: TimestampsUnsortedDetector\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule1\\n          path: \\"/model/LoginDetails/PastTime/Time/Minutes\\"\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule2\\n          path: \\"/model/LoginDetails\\"\\n        - type: ValueMatchRule\\n          id: value_match_rule\\n          path: \\"/model/LoginDetails/Username\\"\\n          value: \\"root\\"\\n        - type: NegationMatchRule\\n          id: negation_match_rule1\\n          sub_rule: \\"value_match_rule\\"\\n        - type: NegationMatchRule\\n          id: negation_match_rule2\\n          sub_rule: \\"path_exists_match_rule2\\"\\n        - type: AndMatchRule\\n          id: and_match_rule1\\n          sub_rules:\\n            - \\"path_exists_match_rule1\\"\\n            - \\"negation_match_rule1\\"\\n        - type: AndMatchRule\\n          id: and_match_rule2\\n          sub_rules:\\n            - \\"negation_match_rule1\\"\\n            - \\"path_exists_match_rule2\\"\\n        - type: OrMatchRule\\n          id: or_match_rule\\n          sub_rules:\\n            - \\"and_match_rule1\\"\\n            - \\"and_match_rule2\\"\\n            - \\"negation_match_rule2\\"\\n        - type: AllowlistViolationDetector\\n          id: Allowlist\\n          allowlist_rules:\\n            - \\"or_match_rule\\"\\n        - type: ParserCount\\n          id: ParserCount\\n          report_interval: 10\\n        - type: MatchFilter\\n          id: MatchFilter\\n          paths:\\n            - \\"/model/Random\\"\\n          value_list:\\n            - 1\\n            - 10\\n            - 100\\n        - type: EnhancedNewMatchPathValueComboDetector\\n          id: EnhancedNewValueCombo\\n          paths:\\n            - \\"/model/DailyCron/UName\\"\\n            - \\"/model/DailyCron/JobNumber\\"\\n          tuple_transformation_function: \\"demo\\"\\n          learn_mode: True\\n        - type: ModuloTimeMatchRule\\n          id: \\"mt\\"\\n          path: \\"mtmr\\"\\n          seconds_modulo: 3\\n          lower_limit: 0\\n          upper_limit: 3\\n        - type: ValueDependentModuloTimeMatchRule\\n          id: \\"vdmt\\"\\n          path: \\"vdmtmr\\"\\n          seconds_modulo: 3\\n          paths:\\n            - \\"/model/ECD/g\\"\\n            - \\"/model/ECD/h\\"\\n            - \\"/model/ECD/i\\"\\n            - \\"/model/ECD/j\\"\\n            - \\"/model/ECD/k\\"\\n            - \\"/model/ECD/l\\"\\n          limit_lookup_dict:\\n            e:\\n              - 0\\n              - 2.95\\n          default_limit:\\n            - 0\\n            - 3\\n        - type: ValueDependentDelegatedMatchRule\\n          id: \\"value_dependent_delegated_match_rule\\"\\n          paths:\\n            - \\"/model/ECD/g\\"\\n            - \\"/model/ECD/h\\"\\n            - \\"/model/ECD/i\\"\\n            - \\"/model/ECD/j\\"\\n            - \\"/model/ECD/k\\"\\n            - \\"/model/ECD/l\\"\\n          rule_lookup_dict:\\n            (b\\"g\\",): \\"mt\\"\\n            (b\\"h\\",): \\"mt\\"\\n            (b\\"i\\",): \\"mt\\"\\n            (b\\"j\\",): \\"vdmt\\"\\n            (b\\"k\\",): \\"vdmt\\"\\n            (b\\"l\\",): \\"vdmt\\"\\n          default_rule: \\"mt\\"\\n        - type: EventGenerationMatchAction\\n          id: \\"ip_match_action\\"\\n          event_type: \\"Analysis.Rules.IPv4InRFC1918MatchRule\\"\\n          event_message: \\"Private IP address occurred!\\"\\n        - type: IPv4InRFC1918MatchRule\\n          id: \\"ipv4_in_rfc1918_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          match_action: \\"ip_match_action\\"\\n        - type: DebugHistoryMatchRule\\n          id: \\"debug_history_match_rule\\"\\n          debug_mode: True\\n        - type: ValueListMatchRule\\n          id: \\"value_list_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          value_list:\\n            - 134744072\\n            - 134743044\\n        - type: NegationMatchRule\\n          id: \\"negation_list\\"\\n          sub_rule: \\"value_list_match_rule\\"\\n        - type: ValueRangeMatchRule\\n          id: \\"value_range_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          lower_limit: 167772160\\n          upper_limit: 184549375\\n        - type: NegationMatchRule\\n          id: \\"negation_range\\"\\n          sub_rule: \\"value_range_match_rule\\"\\n        - type: StringRegexMatchRule\\n          id: \\"string_regex_match_rule\\"\\n          path: \\"/model/type/syscall/success\\"\\n          regex: \\"^no$\\"\\n        - type: NegationMatchRule\\n          id: \\"negation_string_regex\\"\\n          sub_rule: \\"string_regex_match_rule\\"\\n        - type: ParallelMatchRule\\n          id: \\"parallel_match_rule\\"\\n          sub_rules:\\n            - \\"value_dependent_delegated_match_rule\\"\\n            - \\"ipv4_in_rfc1918_match_rule\\"\\n            - \\"debug_history_match_rule\\"\\n        - type: AndMatchRule\\n          id: \\"time_and_match_rule\\"\\n          sub_rules:\\n            - \\"parallel_match_rule\\"\\n            - \\"negation_list\\"\\n            - \\"negation_range\\"\\n            - \\"negation_string_regex\\"\\n        - type: AllowlistViolationDetector\\n          id: TimeAllowlist\\n          allowlist_rules:\\n            - \\"time_and_match_rule\\"\\n        - type: LinearNumericBinDefinition\\n          id: linear_numeric_bin_definition\\n          lower_limit: 50\\n          bin_size: 5\\n          bin_count: 20\\n          outlier_bins_flag: True\\n        - type: ModuloTimeBinDefinition\\n          id: modulo_time_bin_definition\\n          modulo_value: 86400\\n          time_unit: 3600\\n          lower_limit: 0\\n          bin_size: 1\\n          bin_count: 24\\n          outlier_bins_flag: True\\n        - type: HistogramAnalysis\\n          id: HistogramAnalysis\\n          histogram_defs: [[\\"/model/RandomTime/Random\\", \\"linear_numeric_bin_definition\\"]]\\n          report_interval: 10\\n        - type: PathDependentHistogramAnalysis\\n          id: PathDependentHistogramAnalysis\\n          path: \\"/model/RandomTime\\"\\n          bin_definition: \\"modulo_time_bin_definition\\"\\n          report_interval: 10\\n        - type: MatchValueAverageChangeDetector\\n          id: MatchValueAverageChange\\n          timestamp_path: null\\n          paths:\\n            - \\"/model/Random\\"\\n          min_bin_elements: 100\\n          min_bin_time: 10\\n        - type: MatchValueStreamWriter\\n          id: MatchValueStreamWriter\\n          stream: \\"sys.stdout\\"\\n          paths:\\n            - \\"/model/Sensors/CPUTemp\\"\\n            - \\"/model/Sensors/CPUWorkload\\"\\n            - \\"/model/Sensors/DTM\\"\\n          separator: \\";\\"\\n          missing_value_string: \\"\\"\\n        - type: NewMatchPathValueComboDetector\\n          id: NewMatchPathValueCombo\\n          paths:\\n            - \\"/model/IPAddresses/Username\\"\\n            - \\"/model/IPAddresses/IP\\"\\n          learn_mode: False\\n          log_resource_ignore_list:\\n            - \'file:///tmp/other_syslog\'\\n        - type: NewMatchIdValueComboDetector\\n          id: NewMatchIdValueComboDetector\\n          paths:\\n            - \\"/model/type/path/name\\"\\n            - \\"/model/type/syscall/syscall\\"\\n          id_path_list:\\n            - \\"/model/type/path/id\\"\\n            - \\"/model/type/syscall/id\\"\\n          min_allowed_time_diff: 5\\n          allow_missing_values: True\\n          learn_mode: True\\n        - type: NewMatchPathValueDetector\\n          id: NewMatchPathValue\\n          paths:\\n            - \\"/model/DailyCron/JobNumber\\"\\n            - \\"/model/IPAddresses/Username\\"\\n          learn_mode: True\\n        - type: MissingMatchPathValueDetector\\n          id: MissingMatch\\n          paths:\\n            - \\"/model/DiskReport/Space\\"\\n          check_interval: 2\\n          realert_interval: 5\\n          learn_mode: True\\n        - type: TimeCorrelationDetector\\n          id: TimeCorrelationDetector\\n          parallel_check_count: 2\\n          min_rule_attributes: 1\\n          max_rule_attributes: 5\\n          record_count_before_event: 10000\\n        - type: CorrelationRule\\n          rule_id: correlation_rule\\n          min_time_delta: 5\\n          max_time_delta: 6\\n          artefact_match_parameters: [[\\"/model/CronAnnouncement/JobNumber\\", \\"/model/CronExecution/JobNumber\\"]]\\n        - type: EventClassSelector\\n          action_id: a_class_selector\\n          artefact_a_rules:\\n            - correlation_rule\\n        - type: EventClassSelector\\n          action_id: b_class_selector\\n          artefact_b_rules:\\n            - correlation_rule\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule3\\n          path: \\"/model/CronAnnouncement/Run\\"\\n          match_action: a_class_selector\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule4\\n          path: \\"/model/CronExecution/Job\\"\\n          match_action: b_class_selector\\n        - type: TimeCorrelationViolationDetector\\n          id: TimeCorrelationViolationDetector\\n          ruleset:\\n            - path_exists_match_rule3\\n            - path_exists_match_rule4\\n\\nEventHandlers:\\n        - id: stpe\\n          type: StreamPrinterEventHandler\\n\\n        - id: aminer-rest-stpe\\n          type: StreamPrinterEventHandler\\n          json: True\\n          output_file_path: /tmp/aminer-rest-output.log\\n\'"'
        live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        property_name = "Core.PersistencePeriod"
        response = self.client.put("config_property/%s" % property_name, json={"value": 700}, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(self.client.get("config_property/%s" % property_name, headers=self.authorization_headers).content,
                         f"{{\"{property_name}\":700}}".encode())
        self.assertEqual(response.content, f"{{\"message\":\"Successfully changed config property {property_name} to {700}.\"}}".encode())
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        c = contentpy.replace(b'Core.PersistencePeriod\\"] = 600', b'Core.PersistencePeriod\\"] = 700')
        if self.dest_config_file.endswith(".yml"):
            c = contentyml.replace(b'Core.PersistencePeriod: 600', b'Core.PersistencePeriod: 700')
        self.assertEqual(new_live_config, c.decode("unicode-escape"))
        self.assertNotEqual(new_live_config, live_config)
        self.client.put("config_property/%s" % property_name, json={"value": 600}, headers=self.authorization_headers)
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        c = contentpy
        if self.dest_config_file.endswith(".yml"):
            c = contentyml
        self.assertEqual(new_live_config, c.decode("unicode-escape"))

        live_config = new_live_config
        property_name = "MailAlerting.MaxEventsPerMessage"
        response = self.client.put("config_property/%s" % property_name, json={"value": 2}, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(self.client.get("config_property/%s" % property_name, headers=self.authorization_headers).content,
                         f"{{\"{property_name}\":2}}".encode())
        self.assertEqual(response.content, f"{{\"message\":\"Successfully changed config property {property_name} to {2}.\"}}".encode())
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        self.assertNotEqual(new_live_config, live_config)
        c = contentpy.replace(b"MailAlerting.MaxEventsPerMessage'] = 1000", b"MailAlerting.MaxEventsPerMessage'] = 2")
        if self.dest_config_file.endswith(".yml"):
            c = contentyml.replace(b"MailAlerting.MaxEventsPerMessage: 1000", b"MailAlerting.MaxEventsPerMessage: 2")
        self.assertEqual(new_live_config, c.decode("unicode-escape"))
        self.client.put("config_property/%s" % property_name, json={"value": 1000}, headers=self.authorization_headers)
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        c = contentpy
        if self.dest_config_file.endswith(".yml"):
            c = contentyml
        self.assertEqual(new_live_config, c.decode("unicode-escape"))

        response = self.client.put("config_property/%s" % property_name, json={"value": 2})
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape"), live_config)

        response = self.client.put("config_property/%s" % property_name, json={"value": 2}, headers={
            "Authorization": "%s %s" % (self.token_type, self.access_token + "failedtoken")})
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape"), live_config)

        response = self.client.put("config_property/%s" % property_name, json={"value": "2"}, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(self.client.get("config_property/%s" % property_name, headers=self.authorization_headers).content,
                         f"{{\"{property_name}\":1000}}".encode())
        self.assertEqual(response.content, f"{{\"detail\":\"the value of the property '{property_name}' must be of type {type(1000)}!\"}}".encode())
        self.assertEqual(self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape"), live_config)

        property_name = "AminerUser"
        response = self.client.put("config_property/%s" % property_name, json={"value": "new_aminer"}, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(self.client.get("config_property/%s" % property_name, headers=self.authorization_headers).content,
                         f"{{\"{property_name}\":\"aminer\"}}".encode())
        self.assertEqual(response.content, f"{{\"detail\":\"the property '{property_name}' can only be changed at startup in the aminer root process!\"}}".encode())
        self.assertEqual(self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape"), live_config)

        property_name = "LogResourceList"
        response = self.client.put("config_property/%s" % property_name, json={"value": ["file:///tmp/syslog.txt"]},
                                   headers=self.authorization_headers)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(self.client.get("config_property/%s" % property_name, headers=self.authorization_headers).content,
                         f"{{\"{property_name}\":[\"file:///tmp/syslog\",\"file:///tmp/aminer-rest-input.log\"]}}".encode())
        self.assertEqual(response.content, f"{{\"detail\":\"the property '{property_name}' can only be changed at startup in the aminer root process!\"}}".encode())
        self.assertEqual(self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape"), live_config)

        property_name = "NoneExistentConfigProperty"
        response = self.client.put("config_property/%s" % property_name, json={"value": "some string"}, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f'{{"detail":"{ERR_CONFIG_PROPERTY_NOT_EXISTING}"}}'.encode())
        self.assertEqual(self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape"), live_config)

        property_name = "LogResourceList"
        response = self.client.put("config_property/%s" % property_name, json={"value": ["file:///tmp/syslog.txt"]},
                                   headers={"content-md5": "md5 string", **self.authorization_headers})
        self.assertEqual(response.status_code, 501)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f'{{"detail":"{ERR_HEADER_NOT_IMPLEMENTED % "content-md5"}"}}'.encode())
        self.assertEqual(self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape"), live_config)

    def test3get_attribute_of_registered_component(self):
        component_name = "NewMatchPathValueCombo"
        attribute_name = "target_path_list"
        response = self.client.get("attribute/%s/%s" % (component_name, attribute_name), headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f"{{\"{component_name}.{attribute_name}\":[\"/model/IPAddresses/Username\",\"/model/IPAddresses/IP\"]}}".encode())

        response = self.client.get("attribute/%s/%s" % (component_name, attribute_name))
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")

        response = self.client.get("attribute/%s/%s" % (component_name, attribute_name), headers={
            "Authorization": "%s %s" % (self.token_type, self.access_token + "failedtoken")})
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")

        component_name = "NewMatchPathValueComboDetector"
        attribute_name = "target_path_list"
        response = self.client.get("attribute/%s/%s" % (component_name, attribute_name), headers=self.authorization_headers)
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f'{{"detail":"the component \'{component_name}\' does not exist."}}'.encode())

        component_name = "NewMatchPathValueCombo"
        attribute_name = "not_existing_attribute"
        response = self.client.get("attribute/%s/%s" % (component_name, attribute_name), headers=self.authorization_headers)
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f'{{"detail":"the component \'{component_name}\' does not have an attribute named \'{attribute_name}\'."}}'.encode())

        attribute_name = "learn_mode"
        response = self.client.get("attribute/%s/%s" % (component_name, attribute_name), headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f"{{\"{component_name}.{attribute_name}\":false}}".encode())

    def test4put_attribute_of_registered_component(self):
        contentpy = b'"Remote execution response: \'from aminer.parsing.FirstMatchModelElement import FirstMatchModelElement\\nfrom aminer.parsing.SequenceModelElement import SequenceModelElement\\nfrom aminer.parsing.FixedDataModelElement import FixedDataModelElement\\nfrom aminer.parsing.DelimitedDataModelElement import DelimitedDataModelElement\\nfrom aminer.parsing.AnyByteDataModelElement import AnyByteDataModelElement\\nfrom aminer.parsing.FixedWordlistDataModelElement import FixedWordlistDataModelElement\\nfrom aminer.parsing.DecimalIntegerValueModelElement import DecimalIntegerValueModelElement\\nfrom aminer.parsing.DateTimeModelElement import DateTimeModelElement\\nfrom aminer.parsing.IpAddressDataModelElement import IpAddressDataModelElement\\nfrom aminer.parsing.OptionalMatchModelElement import OptionalMatchModelElement\\n\\n# This is a template for the \\"aminer\\" logfile miner tool. Copy\\n# it to \\"config.py\\" and define your ruleset.\\n\\nconfig_properties = {}\\n\\n# Define the list of log resources to read from: the resources\\n# named here do not need to exist when aminer is started. This\\n# will just result in a warning. However, if they exist, they have\\n# to be readable by the aminer process! Supported types are:\\n# * file://[path]: Read data from file, reopen it after rollover\\n# * unix://[path]: Open the path as UNIX local socket for reading\\n\\n# can not use unix socket for aminer-rest, because the socket needs to be open, while aminer-rest needs aminer running at startup.\\nconfig_properties[\'LogResourceList\'] = [\'file:///tmp/syslog\', \'file:///tmp/aminer-rest-input.log\']\\n\\n# Define the uid/gid of the process that runs the calculation\\n# after opening the log files:\\nconfig_properties[\'AminerUser\'] = \'aminer\'\\nconfig_properties[\'AminerGroup\'] = \'aminer\'\\n\\n# Define the path, where aminer will listen for incoming remote\\n# control connections. When missing, no remote control socket\\n# will be created.\\nconfig_properties[\'RemoteControlSocket\'] = \'/var/run/aminer-remote.socket\'\\n\\n# Read the analyis from this file. That part of configuration\\n# is separated from the main configuration so that it can be loaded\\n# only within the analysis child. Non-absolute path names are\\n# interpreted relatively to the main configuration file (this\\n# file). When empty, this configuration has to contain the configuration\\n# for the child also.\\n# config_properties[\'AnalysisConfigFile\'] = \'analysis.py\'\\n\\nconfig_properties[\'Core.LogDir\'] = \'/tmp/lib/aminer/log\'\\n# Read and store information to be used between multiple invocations\\n# of aminer in this directory. The directory must only be accessible\\n# to the \'AminerUser\' but not group/world readable. On violation,\\n# aminer will refuse to start. When undefined, \'/var/lib/aminer\'\\n# is used.\\nconfig_properties[\'Core.PersistenceDir\'] = \'/tmp/lib/aminer\'\\n\\n# Define a target e-mail address to send alerts to. When undefined,\\n# no e-mail notification hooks are added.\\nconfig_properties[\'MailAlerting.TargetAddress\'] = \'root@localhost\'\\n# Sender address of e-mail alerts. When undefined, \\"sendmail\\"\\n# implementation on host will decide, which sender address should\\n# be used.\\nconfig_properties[\'MailAlerting.FromAddress\'] = \'root@localhost\'\\n# Define, which text should be prepended to the standard aminer\\n# subject. Defaults to \\"aminer Alerts:\\"\\nconfig_properties[\'MailAlerting.SubjectPrefix\'] = \'aminer Alerts:\'\\n# Define a grace time after startup before aminer will react to\\n# an event and send the first alert e-mail. Defaults to 0 (any\\n# event can immediately trigger alerting).\\nconfig_properties[\'MailAlerting.AlertGraceTime\'] = 0\\n# Define how many seconds to wait after a first event triggered\\n# the alerting procedure before really sending out the e-mail.\\n# In that timespan, events are collected and will be sent all\\n# using a single e-mail. Defaults to 10 seconds.\\nconfig_properties[\'MailAlerting.EventCollectTime\'] = 0\\n# Define the minimum time between two alert e-mails in seconds\\n# to avoid spamming. All events during this timespan are collected\\n# and sent out with the next report. Defaults to 600 seconds.\\nconfig_properties[\'MailAlerting.MinAlertGap\'] = 0\\n# Define the maximum time between two alert e-mails in seconds.\\n# When undefined this defaults to \\"MailAlerting.MinAlertGap\\".\\n# Otherwise this will activate an exponential backoff to reduce\\n# messages during permanent error states by increasing the alert\\n# gap by 50% when more alert-worthy events were recorded while\\n# the previous gap time was not yet elapsed.\\nconfig_properties[\'MailAlerting.MaxAlertGap\'] = 600\\n# Define how many events should be included in one alert mail\\n# at most. This defaults to 1000\\nconfig_properties[\'MailAlerting.MaxEventsPerMessage\'] = 1000\\nconfig_properties[\'LogPrefix\'] = \'Original log line: \'\\n\\n# Add your ruleset here:\\n\\n\\ndef build_analysis_pipeline(analysis_context):\\n    \\"\\"\\"Define the function to create pipeline for parsing the log data.\\n\\n    It has also to define an AtomizerFactory to instruct aminer how to\\n    process incoming data streams to create log atoms from them.\\n    \\"\\"\\"\\n    # Build the parsing model:\\n\\n    service_children_disk_report = [\\n        FixedDataModelElement(\'Space\', b\' Current Disk Data is: Filesystem     Type  Size  Used Avail Use%\'),\\n        DelimitedDataModelElement(\'Data\', b\'%\'), AnyByteDataModelElement(\'Rest\')]\\n\\n    service_children_login_details = [\\n        FixedDataModelElement(\'User\', b\'User \'), DelimitedDataModelElement(\'Username\', b\' \'),\\n        FixedWordlistDataModelElement(\'Status\', [b\' logged in\', b\' logged out\']),\\n        OptionalMatchModelElement(\'PastTime\', SequenceModelElement(\'Time\', [\\n            FixedDataModelElement(\'Blank\', b\' \'), DecimalIntegerValueModelElement(\'Minutes\'),\\n            FixedDataModelElement(\'Ago\', b\' minutes ago.\')]))]\\n\\n    service_children_cron_job = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'UNameSpace1\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'UNameSpace2\', b\' \'), DelimitedDataModelElement(\'User\', b\' \'),\\n        FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Details\', b\']: Job `cron.daily` started.\')]\\n\\n    service_children_random_time = [FixedDataModelElement(\'Space\', b\'Random: \'), DecimalIntegerValueModelElement(\'Random\')]\\n\\n    service_children_sensors = [SequenceModelElement(\'CPUTemp\', [\\n        FixedDataModelElement(\'FixedTemp\', b\'CPU Temp: \'), DecimalIntegerValueModelElement(\'Temp\'),\\n        FixedDataModelElement(\'Degrees\', b\'\\\\xc2\\\\xb0C\')]), FixedDataModelElement(\'Space1\', b\', \'), SequenceModelElement(\'CPUWorkload\', [\\n            FixedDataModelElement(\'FixedWorkload\', b\'CPUWorkload: \'), DecimalIntegerValueModelElement(\'Workload\'),\\n            FixedDataModelElement(\'Percent\', b\'%\')]), FixedDataModelElement(\'Space2\', b\', \'),\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\')]\\n\\n    service_children_user_ip_address = [\\n        FixedDataModelElement(\'User\', b\'User \'), DelimitedDataModelElement(\'Username\', b\' \'),\\n        FixedDataModelElement(\'Action\', b\' changed IP address to \'), IpAddressDataModelElement(\'IP\')]\\n\\n    service_children_cron_job_announcement = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'Space\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Run\', b\']: Will run job `\'),\\n        FixedWordlistDataModelElement(\'CronType\', [b\'cron.daily\', b\'cron.hourly\', b\'cron.monthly\', b\'cron.weekly\']),\\n        FixedDataModelElement(\'StartTime\', b\'\\\\\' in 5 min.\')]\\n\\n    service_children_cron_job_execution = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'Space1\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Job\', b\']: Job `\'),\\n        FixedWordlistDataModelElement(\'CronType\', [b\'cron.daily\', b\'cron.hourly\', b\'cron.monthly\', b\'cron.weekly\']),\\n        FixedDataModelElement(\'Started\', b\'\\\\\' started\')]\\n\\n    parsing_model = FirstMatchModelElement(\'model\', [\\n        SequenceModelElement(\'CronAnnouncement\', service_children_cron_job_announcement),\\n        SequenceModelElement(\'CronExecution\', service_children_cron_job_execution),\\n        SequenceModelElement(\'DailyCron\', service_children_cron_job), SequenceModelElement(\'DiskReport\', service_children_disk_report),\\n        SequenceModelElement(\'LoginDetails\', service_children_login_details), DecimalIntegerValueModelElement(\'Random\'),\\n        SequenceModelElement(\'RandomTime\', service_children_random_time), SequenceModelElement(\'Sensors\', service_children_sensors),\\n        SequenceModelElement(\'IPAddresses\', service_children_user_ip_address)])\\n\\n    # Some generic imports.\\n    from aminer.analysis import AtomFilters\\n\\n    # Create all global handler lists here and append the real handlers later on.\\n    # Use this filter to distribute all atoms to the analysis handlers.\\n    atom_filters = AtomFilters.SubhandlerFilter(None)\\n    analysis_context.register_component(atom_filters, component_name=\\"AtomFilter\\")\\n\\n    from aminer.analysis.TimestampCorrectionFilters import SimpleMonotonicTimestampAdjust\\n    simple_monotonic_timestamp_adjust = SimpleMonotonicTimestampAdjust([atom_filters])\\n    analysis_context.register_component(simple_monotonic_timestamp_adjust, component_name=\\"SimpleMonotonicTimestampAdjust\\")\\n\\n    from aminer.events.StreamPrinterEventHandler import StreamPrinterEventHandler\\n    import os\\n    import stat\\n    stpe = StreamPrinterEventHandler(analysis_context)\\n    aminer_rest_output = "/tmp/aminer-rest-output.log"\\n    mode = \'w+\'\\n    if os.path.exists(aminer_rest_output) and stat.S_ISFIFO(os.stat(aminer_rest_output).st_mode):\\n        mode = \'w\'\\n    stream = open(aminer_rest_output, mode)\\n    aminer_rest_stpe = StreamPrinterEventHandler(analysis_context, stream)\\n    from aminer.events.JsonConverterHandler import JsonConverterHandler\\n    aminer_rest_jch = JsonConverterHandler([aminer_rest_stpe], analysis_context, pretty_print=False)\\n\\n    from aminer.events.Utils import VolatileLogarithmicBackoffEventHistory\\n    volatile_logarithmic_backoff_event_history = VolatileLogarithmicBackoffEventHistory(100)\\n    anomaly_event_handlers = [stpe, aminer_rest_jch, volatile_logarithmic_backoff_event_history]\\n    analysis_context.register_component(volatile_logarithmic_backoff_event_history, component_name=\\"VolatileLogarithmicBackoffEventHistory\\")\\n\\n    # Now define the AtomizerFactory using the model. A simple line based one is usually sufficient.\\n    from aminer.input.SimpleByteStreamLineAtomizerFactory import SimpleByteStreamLineAtomizerFactory\\n    analysis_context.atomizer_factory = SimpleByteStreamLineAtomizerFactory(\\n        parsing_model, [simple_monotonic_timestamp_adjust], anomaly_event_handlers, use_real_time=True)\\n\\n    # Just report all unparsed atoms to the event handlers.\\n    from aminer.analysis.UnparsedAtomHandlers import SimpleUnparsedAtomHandler\\n    simple_unparsed_atom_handler = SimpleUnparsedAtomHandler(anomaly_event_handlers)\\n    atom_filters.add_handler(simple_unparsed_atom_handler, stop_when_handled_flag=True)\\n    analysis_context.register_component(simple_unparsed_atom_handler, component_name=\\"UnparsedHandler\\")\\n\\n    from aminer.analysis.TimestampsUnsortedDetector import TimestampsUnsortedDetector\\n    timestamps_unsorted_detector = TimestampsUnsortedDetector(analysis_context.aminer_config, anomaly_event_handlers)\\n    atom_filters.add_handler(timestamps_unsorted_detector)\\n    analysis_context.register_component(timestamps_unsorted_detector, component_name=\\"TimestampsUnsortedDetector\\")\\n\\n    from aminer.analysis import Rules\\n    from aminer.analysis.AllowlistViolationDetector import AllowlistViolationDetector\\n    allowlist_rules = [\\n        Rules.OrMatchRule([\\n            Rules.AndMatchRule([\\n                Rules.PathExistsMatchRule(\'/model/LoginDetails/PastTime/Time/Minutes\'),\\n                Rules.NegationMatchRule(Rules.ValueMatchRule(\'/model/LoginDetails/Username\', b\'root\'))]),\\n            Rules.AndMatchRule([\\n                Rules.NegationMatchRule(Rules.PathExistsMatchRule(\'/model/LoginDetails/PastTime/Time/Minutes\')),\\n                Rules.PathExistsMatchRule(\'/model/LoginDetails\')]),\\n            Rules.NegationMatchRule(Rules.PathExistsMatchRule(\'/model/LoginDetails\'))])]\\n\\n    # This rule list should trigger, when the line does not look like: User root (logged in, logged out)\\n    # or User \'username\' (logged in, logged out) x minutes ago.\\n    allowlist_violation_detector = AllowlistViolationDetector(analysis_context.aminer_config, allowlist_rules, anomaly_event_handlers)\\n    analysis_context.register_component(allowlist_violation_detector, component_name=\\"Allowlist\\")\\n    atom_filters.add_handler(allowlist_violation_detector)\\n\\n    from aminer.analysis.ParserCount import ParserCount\\n    parser_count = ParserCount(analysis_context.aminer_config, None, anomaly_event_handlers, 10)\\n    analysis_context.register_component(parser_count, component_name=\\"ParserCount\\")\\n    atom_filters.add_handler(parser_count)\\n\\n    from aminer.analysis.EventCorrelationDetector import EventCorrelationDetector\\n    ecd = EventCorrelationDetector(analysis_context.aminer_config, anomaly_event_handlers, check_rules_flag=True,\\n                                   hypothesis_max_delta_time=1.0, learn_mode=True)\\n    analysis_context.register_component(ecd, component_name=\\"EventCorrelationDetector\\")\\n    atom_filters.add_handler(ecd)\\n\\n    from aminer.analysis.NewMatchPathDetector import NewMatchPathDetector\\n    new_match_path_detector = NewMatchPathDetector(analysis_context.aminer_config, anomaly_event_handlers, learn_mode=True)\\n    analysis_context.register_component(new_match_path_detector, component_name=\\"NewMatchPath\\")\\n    atom_filters.add_handler(new_match_path_detector)\\n\\n    def tuple_transformation_function(match_value_list):\\n        \\"\\"\\"Only allow output of the EnhancedNewMatchPathValueComboDetector\\n        after every 10000th element.\\"\\"\\"\\n        extra_data = enhanced_new_match_path_value_combo_detector.known_values_dict.get(tuple(match_value_list))\\n        if extra_data is not None:\\n            mod = 10000\\n            if (extra_data[2] + 1) % mod == 0:\\n                enhanced_new_match_path_value_combo_detector.learn_mode = False\\n            else:\\n                enhanced_new_match_path_value_combo_detector.learn_mode = True\\n        return match_value_list\\n\\n    from aminer.analysis.EnhancedNewMatchPathValueComboDetector import EnhancedNewMatchPathValueComboDetector\\n    enhanced_new_match_path_value_combo_detector = EnhancedNewMatchPathValueComboDetector(\\n        analysis_context.aminer_config, [\'/model/DailyCron/UName\', \'/model/DailyCron/JobNumber\'], anomaly_event_handlers,\\n        learn_mode=False, tuple_transformation_function=tuple_transformation_function)\\n    analysis_context.register_component(enhanced_new_match_path_value_combo_detector, component_name=\\"EnhancedNewValueCombo\\")\\n    atom_filters.add_handler(enhanced_new_match_path_value_combo_detector)\\n\\n    from aminer.analysis.HistogramAnalysis import HistogramAnalysis, LinearNumericBinDefinition, ModuloTimeBinDefinition, \\\\\\n        PathDependentHistogramAnalysis\\n    modulo_time_bin_definition = ModuloTimeBinDefinition(86400, 3600, 0, 1, 24, True)\\n    linear_numeric_bin_definition = LinearNumericBinDefinition(50, 5, 20, True)\\n    histogram_analysis = HistogramAnalysis(analysis_context.aminer_config, [\\n        (\'/model/RandomTime/Random\', modulo_time_bin_definition), (\'/model/Random\', linear_numeric_bin_definition)], 10,\\n        anomaly_event_handlers)\\n    analysis_context.register_component(histogram_analysis, component_name=\\"HistogramAnalysis\\")\\n    atom_filters.add_handler(histogram_analysis)\\n\\n    path_dependent_histogram_analysis = PathDependentHistogramAnalysis(analysis_context.aminer_config, \'/model/RandomTime\',\\n                                                                       modulo_time_bin_definition, 10, anomaly_event_handlers)\\n    analysis_context.register_component(path_dependent_histogram_analysis, component_name=\\"PathDependentHistogramAnalysis\\")\\n    atom_filters.add_handler(path_dependent_histogram_analysis)\\n\\n    from aminer.analysis.MatchValueAverageChangeDetector import MatchValueAverageChangeDetector\\n    match_value_average_change_detector = MatchValueAverageChangeDetector(analysis_context.aminer_config, anomaly_event_handlers, None,\\n                                                                          [\'/model/Random\'], 100, 10)\\n    analysis_context.register_component(match_value_average_change_detector, component_name=\\"MatchValueAverageChange\\")\\n    atom_filters.add_handler(match_value_average_change_detector)\\n\\n    import sys\\n    from aminer.analysis.MatchValueStreamWriter import MatchValueStreamWriter\\n    match_value_stream_writer = MatchValueStreamWriter(\\n        sys.stdout, [\'/model/Sensors/CPUTemp\', \'/model/Sensors/CPUWorkload\', \'/model/Sensors/DTM\'], b\';\', b\'\')\\n    analysis_context.register_component(match_value_stream_writer, component_name=\\"MatchValueStreamWriter\\")\\n    atom_filters.add_handler(match_value_stream_writer)\\n\\n    from aminer.analysis.NewMatchPathValueComboDetector import NewMatchPathValueComboDetector\\n    new_match_path_value_combo_detector = NewMatchPathValueComboDetector(analysis_context.aminer_config, [\\n        \'/model/IPAddresses/Username\', \'/model/IPAddresses/IP\'], anomaly_event_handlers, learn_mode=False)\\n    analysis_context.register_component(new_match_path_value_combo_detector, component_name=\\"NewMatchPathValueCombo\\")\\n    atom_filters.add_handler(new_match_path_value_combo_detector)\\n\\n    from aminer.analysis.NewMatchIdValueComboDetector import NewMatchIdValueComboDetector\\n    new_match_id_value_combo_detector = NewMatchIdValueComboDetector(\\n        analysis_context.aminer_config, [\'/model/type/path/id\', \'/model/type/syscall/id\'], anomaly_event_handlers,\\n        id_path_list=[\'/model/type/path/id\', \'/model/type/syscall/id\'], min_allowed_time_diff=5, learn_mode=True,\\n        allow_missing_values_flag=True, output_logline=True)\\n    analysis_context.register_component(new_match_id_value_combo_detector, component_name=\\"NewMatchIdValueComboDetector\\")\\n    atom_filters.add_handler(new_match_id_value_combo_detector)\\n\\n    from aminer.analysis.NewMatchPathValueDetector import NewMatchPathValueDetector\\n    new_match_path_value_detector = NewMatchPathValueDetector(analysis_context.aminer_config, [\\n        \'/model/DailyCron/Job Number\', \'/model/IPAddresses/Username\'], anomaly_event_handlers, learn_mode=False)\\n    analysis_context.register_component(new_match_path_value_detector, component_name=\\"NewMatchPathValue\\")\\n    atom_filters.add_handler(new_match_path_value_detector)\\n\\n    from aminer.analysis.MissingMatchPathValueDetector import MissingMatchPathValueDetector\\n    missing_match_path_value_detector = MissingMatchPathValueDetector(\\n        analysis_context.aminer_config, [\'/model/DiskReport/Space\'], anomaly_event_handlers, learn_mode=False, default_interval=2,\\n        realert_interval=5)\\n    analysis_context.register_component(missing_match_path_value_detector, component_name=\\"MissingMatch\\")\\n    atom_filters.add_handler(missing_match_path_value_detector)\\n\\n    from aminer.analysis.TimeCorrelationDetector import TimeCorrelationDetector\\n    time_correlation_detector = TimeCorrelationDetector(\\n        analysis_context.aminer_config, anomaly_event_handlers, 2, min_rule_attributes=1, max_rule_attributes=5,\\n        record_count_before_event=70000, output_logline=True)\\n    analysis_context.register_component(time_correlation_detector, component_name=\\"TimeCorrelationDetector\\")\\n    atom_filters.add_handler(time_correlation_detector)\\n\\n    from aminer.analysis.TimeCorrelationViolationDetector import TimeCorrelationViolationDetector, CorrelationRule, EventClassSelector\\n    cron_job_announcement = CorrelationRule(\'CronJobAnnouncement\', 5, 6, artefact_match_parameters=[\\n        (\'/model/CronAnnouncement/JobNumber\', \'/model/CronExecution/JobNumber\')])\\n    a_class_selector = EventClassSelector(\'Announcement\', [cron_job_announcement], None)\\n    b_class_selector = EventClassSelector(\'Execution\', None, [cron_job_announcement])\\n    rules = [Rules.PathExistsMatchRule(\'/model/CronAnnouncement/Run\', a_class_selector),\\n             Rules.PathExistsMatchRule(\'/model/CronExecution/Job\', b_class_selector)]\\n\\n    time_correlation_violation_detector = TimeCorrelationViolationDetector(analysis_context.aminer_config, rules, anomaly_event_handlers)\\n    analysis_context.register_component(time_correlation_violation_detector, component_name=\\"TimeCorrelationViolationDetector\\")\\n    atom_filters.add_handler(time_correlation_violation_detector)\\n\\n    from aminer.events.DefaultMailNotificationEventHandler import DefaultMailNotificationEventHandler\\n    if DefaultMailNotificationEventHandler.CONFIG_KEY_MAIL_TARGET_ADDRESS in analysis_context.aminer_config.config_properties:\\n        mail_notification_handler = DefaultMailNotificationEventHandler(analysis_context)\\n        analysis_context.register_component(mail_notification_handler, component_name=\\"MailHandler\\")\\n        anomaly_event_handlers.append(mail_notification_handler)\\n\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600\'"'
        contentyml = b'"Remote execution response: \'LearnMode: False\\n\\nCore.LogDir: \'/tmp/lib/aminer/log\'\\n\\nCore.PersistenceDir: \'/tmp/lib/aminer\'\\n\\nCore.PersistencePeriod: 600\\n\\n# can not use unix socket for aminer-rest, because the socket needs to be open, while aminer-rest needs aminer running at startup.\\nLogResourceList:\\n        - \'file:///tmp/syslog\'\\n        - \'file:///tmp/aminer-rest-input.log\'\\n\\nRemoteControlSocket: \'/var/run/aminer-remote.socket\'\\n\\nMailAlerting.TargetAddress: \'root@localhost\'\\n\\nMailAlerting.FromAddress: \'root@localhost\'\\n\\nMailAlerting.SubjectPrefix: \'aminer Alerts:\'\\n\\nMailAlerting.AlertGraceTime: 0\\n\\nMailAlerting.EventCollectTime: 0\\n\\nMailAlerting.MinAlertGap: 0\\n\\nMailAlerting.MaxAlertGap: 600\\n\\nMailAlerting.MaxEventsPerMessage: 1000\\n\\nLogPrefix: \'Original log line: \'\\n\\nAminerId: \'demo-aminer\'\\n\\nParser:\\n       - id: space\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \' Current Disk Data is: Filesystem     Type  Size  Used Avail Use%\'\\n\\n       - id: data\\n         type: DelimitedDataModelElement\\n         name: \'Data\'\\n         delimiter: \'%\'\'/\'\\n\\n       - id: rest\\n         type: AnyByteDataModelElement\\n         name: \'Rest\'\\n\\n       - id: userLoginDetails\\n         type: FixedDataModelElement\\n         name: \'User\'\\n         args: \'User \'\\n\\n       - id: userIpAddress\\n         type: FixedDataModelElement\\n         name: \'User\'\\n         args: \'User \'\\n\\n       - id: username\\n         type: DelimitedDataModelElement\\n         name: \'Username\'\\n         delimiter: \' \'\\n\\n       - id: status\\n         type: FixedWordlistDataModelElement\\n         name: \'Status\'\\n         args:\\n           - \' logged in\'\\n           - \' logged out\'\\n\\n       - id: blank\\n         type: FixedDataModelElement\\n         name: \'Blank\'\\n         args: \' \'\\n\\n       - id: minutes\\n         type: DecimalIntegerValueModelElement\\n         name: \'Minutes\'\\n\\n       - id: ago\\n         type: FixedDataModelElement\\n         name: \'Ago\'\\n         args: \' minutes ago.\'\\n\\n       - id: time\\n         type: SequenceModelElement\\n         name: \'Time\'\\n         args:\\n           - blank\\n           - minutes\\n           - ago\\n\\n       - id: pastTime\\n         type: OptionalMatchModelElement\\n         name: \'PastTime\'\\n         args: time\\n\\n       - id: dtm\\n         type: DateTimeModelElement\\n         name: \'DTM\'\\n         date_format: \'%Y-%m-%d %H:%M:%S\'\\n         start_year: null\\n         text_locale: null\\n         max_time_jump_seconds: 86400\\n\\n       - id: uNameSpace1\\n         type: FixedDataModelElement\\n         name: \'UNameSpace1\'\\n         args: \' \'\\n\\n       - id: uName\\n         type: DelimitedDataModelElement\\n         name: \'UName\'\\n         delimiter: \' \'\\n\\n       - id: uNameSpace2\\n         type: FixedDataModelElement\\n         name: \'UNameSpace2\'\\n         args: \' \'\\n\\n       - id: delimitedUser\\n         type: DelimitedDataModelElement\\n         name: \'User\'\\n         delimiter: \' \'\\n\\n       - id: cron\\n         type: FixedDataModelElement\\n         name: \'Cron\'\\n         args: \' cron[\'\\n\\n       - id: jobNumber\\n         type: DecimalIntegerValueModelElement\\n         name: \'JobNumber\'\\n\\n       - id: details\\n         type: FixedDataModelElement\\n         name: \'Details\'\\n         args: \']: Job `cron.daily` started.\'\\n\\n       - id: spaceRandom\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \'Random: \'\\n\\n       - id: random\\n         type: DecimalIntegerValueModelElement\\n         name: \'Random\'\\n\\n       - id: fixedTemp\\n         type: FixedDataModelElement\\n         name: \'FixedTemp\'\\n         args: \'CPU Temp: \'\\n\\n       - id: temp\\n         type: DecimalIntegerValueModelElement\\n         name: \'Temp\'\\n\\n       - id: degrees\\n         type: FixedDataModelElement\\n         name: \'Degrees\'\\n         args: \'\xc2\xb0C\'\\n\\n       - id: cpuTemp\\n         type: SequenceModelElement\\n         name: \'CPUTemp\'\\n         args:\\n           - fixedTemp\\n           - temp\\n           - degrees\\n\\n       - id: space1\\n         type: FixedDataModelElement\\n         name: \'Space1\'\\n         args: \', \'\\n\\n       - id: fixedWorkload\\n         type: FixedDataModelElement\\n         name: \'FixedWorkload\'\\n         args: \'CPU Workload: \'\\n\\n       - id: workload\\n         type: DecimalIntegerValueModelElement\\n         name: \'Workload\'\\n\\n       - id: percent\\n         type: FixedDataModelElement\\n         name: \'Percent\'\\n         args: \'%\'\\n\\n       - id: cpuWorkload\\n         type: SequenceModelElement\\n         name: \'CPUWorkload\'\\n         args:\\n           - fixedWorkload\\n           - workload\\n           - percent\\n\\n       - id: space2\\n         type: FixedDataModelElement\\n         name: \'Space2\'\\n         args: \', \'\\n\\n       - id: action\\n         type: FixedDataModelElement\\n         name: \'Action\'\\n         args: \' changed IP address to \'\\n\\n       - id: ip\\n         type: IpAddressDataModelElement\\n         name: \'IP\'\\n\\n       - id: fixedSpace\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \' \'\\n\\n       - id: run\\n         type: FixedDataModelElement\\n         name: \'Run\'\\n         args: \']: Will run job `\'\\n\\n       - id: cronType\\n         type: FixedWordlistDataModelElement\\n         name: \'CronType\'\\n         args:\\n           - \'cron.daily\'\\n           - \'cron.hourly\'\\n           - \'cron.monthly\'\\n           - \'cron.weekly\'\\n\\n       - id: startTime\\n         type: FixedDataModelElement\\n         name: \'StartTime\'\\n         args: \\"\' in 5 min.\\"\\n\\n       - id: emptySpace1\\n         type: FixedDataModelElement\\n         name: \'Space1\'\\n         args: \' \'\\n\\n       - id: job\\n         type: FixedDataModelElement\\n         name: \'Job\'\\n         args: \']: Job `\'\\n\\n       - id: started\\n         type: FixedDataModelElement\\n         name: \'Started\'\\n         args: \\"\' started\\"\\n\\n       - id: cronAnnouncement\\n         type: SequenceModelElement\\n         name: \'CronAnnouncement\'\\n         args:\\n           - dtm\\n           - fixedSpace\\n           - uName\\n           - cron\\n           - jobNumber\\n           - run\\n           - cronType\\n           - startTime\\n\\n       - id: cronExecution\\n         type: SequenceModelElement\\n         name: \'CronExecution\'\\n         args:\\n           - dtm\\n           - emptySpace1\\n           - uName\\n           - cron\\n           - jobNumber\\n           - job\\n           - cronType\\n           - started\\n\\n       - id: dailyCron\\n         type: SequenceModelElement\\n         name: \'DailyCron\'\\n         args:\\n           - dtm\\n           - uNameSpace1\\n           - uName\\n           - uNameSpace2\\n           - delimitedUser\\n           - cron\\n           - jobNumber\\n           - details\\n\\n       - id: diskReport\\n         type: SequenceModelElement\\n         name: \'DiskReport\'\\n         args:\\n           - space\\n           - data\\n           - rest\\n\\n       - id: loginDetails\\n         type: SequenceModelElement\\n         name: \'LoginDetails\'\\n         args:\\n           - userLoginDetails\\n           - username\\n           - status\\n           - pastTime\\n\\n       - id: randomTime\\n         type: SequenceModelElement\\n         name: \'RandomTime\'\\n         args:\\n           - spaceRandom\\n           - random\\n\\n       - id: sensors\\n         type: SequenceModelElement\\n         name: \'Sensors\'\\n         args:\\n           - cpuTemp\\n           - space1\\n           - cpuWorkload\\n           - space2\\n           - dtm\\n\\n       - id: ipAddresses\\n         type: SequenceModelElement\\n         name: \'IPAddresses\'\\n         args:\\n           - userIpAddress\\n           - username\\n           - action\\n           - ip\\n\\n       - id: model\\n         start: True\\n         type: FirstMatchModelElement\\n         name: \'model\'\\n         args:\\n           - cronAnnouncement\\n           - cronExecution\\n           - dailyCron\\n           - diskReport\\n           - loginDetails\\n           - random\\n           - randomTime\\n           - sensors\\n           - ipAddresses\\n\\nInput:\\n        timestamp_paths: [\\"/model/DailyCron/DTM\\"]\\n        adjust_timestamps: True\\n        use_real_time: True\\n\\nAnalysis:\\n        - type: TimestampsUnsortedDetector\\n          id: TimestampsUnsortedDetector\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule1\\n          path: \\"/model/LoginDetails/PastTime/Time/Minutes\\"\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule2\\n          path: \\"/model/LoginDetails\\"\\n        - type: ValueMatchRule\\n          id: value_match_rule\\n          path: \\"/model/LoginDetails/Username\\"\\n          value: \\"root\\"\\n        - type: NegationMatchRule\\n          id: negation_match_rule1\\n          sub_rule: \\"value_match_rule\\"\\n        - type: NegationMatchRule\\n          id: negation_match_rule2\\n          sub_rule: \\"path_exists_match_rule2\\"\\n        - type: AndMatchRule\\n          id: and_match_rule1\\n          sub_rules:\\n            - \\"path_exists_match_rule1\\"\\n            - \\"negation_match_rule1\\"\\n        - type: AndMatchRule\\n          id: and_match_rule2\\n          sub_rules:\\n            - \\"negation_match_rule1\\"\\n            - \\"path_exists_match_rule2\\"\\n        - type: OrMatchRule\\n          id: or_match_rule\\n          sub_rules:\\n            - \\"and_match_rule1\\"\\n            - \\"and_match_rule2\\"\\n            - \\"negation_match_rule2\\"\\n        - type: AllowlistViolationDetector\\n          id: Allowlist\\n          allowlist_rules:\\n            - \\"or_match_rule\\"\\n        - type: ParserCount\\n          id: ParserCount\\n          report_interval: 10\\n        - type: MatchFilter\\n          id: MatchFilter\\n          paths:\\n            - \\"/model/Random\\"\\n          value_list:\\n            - 1\\n            - 10\\n            - 100\\n        - type: EnhancedNewMatchPathValueComboDetector\\n          id: EnhancedNewValueCombo\\n          paths:\\n            - \\"/model/DailyCron/UName\\"\\n            - \\"/model/DailyCron/JobNumber\\"\\n          tuple_transformation_function: \\"demo\\"\\n          learn_mode: True\\n        - type: ModuloTimeMatchRule\\n          id: \\"mt\\"\\n          path: \\"mtmr\\"\\n          seconds_modulo: 3\\n          lower_limit: 0\\n          upper_limit: 3\\n        - type: ValueDependentModuloTimeMatchRule\\n          id: \\"vdmt\\"\\n          path: \\"vdmtmr\\"\\n          seconds_modulo: 3\\n          paths:\\n            - \\"/model/ECD/g\\"\\n            - \\"/model/ECD/h\\"\\n            - \\"/model/ECD/i\\"\\n            - \\"/model/ECD/j\\"\\n            - \\"/model/ECD/k\\"\\n            - \\"/model/ECD/l\\"\\n          limit_lookup_dict:\\n            e:\\n              - 0\\n              - 2.95\\n          default_limit:\\n            - 0\\n            - 3\\n        - type: ValueDependentDelegatedMatchRule\\n          id: \\"value_dependent_delegated_match_rule\\"\\n          paths:\\n            - \\"/model/ECD/g\\"\\n            - \\"/model/ECD/h\\"\\n            - \\"/model/ECD/i\\"\\n            - \\"/model/ECD/j\\"\\n            - \\"/model/ECD/k\\"\\n            - \\"/model/ECD/l\\"\\n          rule_lookup_dict:\\n            (b\\"g\\",): \\"mt\\"\\n            (b\\"h\\",): \\"mt\\"\\n            (b\\"i\\",): \\"mt\\"\\n            (b\\"j\\",): \\"vdmt\\"\\n            (b\\"k\\",): \\"vdmt\\"\\n            (b\\"l\\",): \\"vdmt\\"\\n          default_rule: \\"mt\\"\\n        - type: EventGenerationMatchAction\\n          id: \\"ip_match_action\\"\\n          event_type: \\"Analysis.Rules.IPv4InRFC1918MatchRule\\"\\n          event_message: \\"Private IP address occurred!\\"\\n        - type: IPv4InRFC1918MatchRule\\n          id: \\"ipv4_in_rfc1918_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          match_action: \\"ip_match_action\\"\\n        - type: DebugHistoryMatchRule\\n          id: \\"debug_history_match_rule\\"\\n          debug_mode: True\\n        - type: ValueListMatchRule\\n          id: \\"value_list_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          value_list:\\n            - 134744072\\n            - 134743044\\n        - type: NegationMatchRule\\n          id: \\"negation_list\\"\\n          sub_rule: \\"value_list_match_rule\\"\\n        - type: ValueRangeMatchRule\\n          id: \\"value_range_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          lower_limit: 167772160\\n          upper_limit: 184549375\\n        - type: NegationMatchRule\\n          id: \\"negation_range\\"\\n          sub_rule: \\"value_range_match_rule\\"\\n        - type: StringRegexMatchRule\\n          id: \\"string_regex_match_rule\\"\\n          path: \\"/model/type/syscall/success\\"\\n          regex: \\"^no$\\"\\n        - type: NegationMatchRule\\n          id: \\"negation_string_regex\\"\\n          sub_rule: \\"string_regex_match_rule\\"\\n        - type: ParallelMatchRule\\n          id: \\"parallel_match_rule\\"\\n          sub_rules:\\n            - \\"value_dependent_delegated_match_rule\\"\\n            - \\"ipv4_in_rfc1918_match_rule\\"\\n            - \\"debug_history_match_rule\\"\\n        - type: AndMatchRule\\n          id: \\"time_and_match_rule\\"\\n          sub_rules:\\n            - \\"parallel_match_rule\\"\\n            - \\"negation_list\\"\\n            - \\"negation_range\\"\\n            - \\"negation_string_regex\\"\\n        - type: AllowlistViolationDetector\\n          id: TimeAllowlist\\n          allowlist_rules:\\n            - \\"time_and_match_rule\\"\\n        - type: LinearNumericBinDefinition\\n          id: linear_numeric_bin_definition\\n          lower_limit: 50\\n          bin_size: 5\\n          bin_count: 20\\n          outlier_bins_flag: True\\n        - type: ModuloTimeBinDefinition\\n          id: modulo_time_bin_definition\\n          modulo_value: 86400\\n          time_unit: 3600\\n          lower_limit: 0\\n          bin_size: 1\\n          bin_count: 24\\n          outlier_bins_flag: True\\n        - type: HistogramAnalysis\\n          id: HistogramAnalysis\\n          histogram_defs: [[\\"/model/RandomTime/Random\\", \\"linear_numeric_bin_definition\\"]]\\n          report_interval: 10\\n        - type: PathDependentHistogramAnalysis\\n          id: PathDependentHistogramAnalysis\\n          path: \\"/model/RandomTime\\"\\n          bin_definition: \\"modulo_time_bin_definition\\"\\n          report_interval: 10\\n        - type: MatchValueAverageChangeDetector\\n          id: MatchValueAverageChange\\n          timestamp_path: null\\n          paths:\\n            - \\"/model/Random\\"\\n          min_bin_elements: 100\\n          min_bin_time: 10\\n        - type: MatchValueStreamWriter\\n          id: MatchValueStreamWriter\\n          stream: \\"sys.stdout\\"\\n          paths:\\n            - \\"/model/Sensors/CPUTemp\\"\\n            - \\"/model/Sensors/CPUWorkload\\"\\n            - \\"/model/Sensors/DTM\\"\\n          separator: \\";\\"\\n          missing_value_string: \\"\\"\\n        - type: NewMatchPathValueComboDetector\\n          id: NewMatchPathValueCombo\\n          paths:\\n            - \\"/model/IPAddresses/Username\\"\\n            - \\"/model/IPAddresses/IP\\"\\n          learn_mode: False\\n          log_resource_ignore_list:\\n            - \'file:///tmp/other_syslog\'\\n        - type: NewMatchIdValueComboDetector\\n          id: NewMatchIdValueComboDetector\\n          paths:\\n            - \\"/model/type/path/name\\"\\n            - \\"/model/type/syscall/syscall\\"\\n          id_path_list:\\n            - \\"/model/type/path/id\\"\\n            - \\"/model/type/syscall/id\\"\\n          min_allowed_time_diff: 5\\n          allow_missing_values: True\\n          learn_mode: True\\n        - type: NewMatchPathValueDetector\\n          id: NewMatchPathValue\\n          paths:\\n            - \\"/model/DailyCron/JobNumber\\"\\n            - \\"/model/IPAddresses/Username\\"\\n          learn_mode: True\\n        - type: MissingMatchPathValueDetector\\n          id: MissingMatch\\n          paths:\\n            - \\"/model/DiskReport/Space\\"\\n          check_interval: 2\\n          realert_interval: 5\\n          learn_mode: True\\n        - type: TimeCorrelationDetector\\n          id: TimeCorrelationDetector\\n          parallel_check_count: 2\\n          min_rule_attributes: 1\\n          max_rule_attributes: 5\\n          record_count_before_event: 10000\\n        - type: CorrelationRule\\n          rule_id: correlation_rule\\n          min_time_delta: 5\\n          max_time_delta: 6\\n          artefact_match_parameters: [[\\"/model/CronAnnouncement/JobNumber\\", \\"/model/CronExecution/JobNumber\\"]]\\n        - type: EventClassSelector\\n          action_id: a_class_selector\\n          artefact_a_rules:\\n            - correlation_rule\\n        - type: EventClassSelector\\n          action_id: b_class_selector\\n          artefact_b_rules:\\n            - correlation_rule\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule3\\n          path: \\"/model/CronAnnouncement/Run\\"\\n          match_action: a_class_selector\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule4\\n          path: \\"/model/CronExecution/Job\\"\\n          match_action: b_class_selector\\n        - type: TimeCorrelationViolationDetector\\n          id: TimeCorrelationViolationDetector\\n          ruleset:\\n            - path_exists_match_rule3\\n            - path_exists_match_rule4\\n\\nEventHandlers:\\n        - id: stpe\\n          type: StreamPrinterEventHandler\\n\\n        - id: aminer-rest-stpe\\n          type: StreamPrinterEventHandler\\n          json: True\\n          output_file_path: /tmp/aminer-rest-output.log\\n\'"'
        component_name = "NewMatchPathValueCombo"
        attribute_name = "learn_mode"
        response = self.client.put("attribute/%s/%s" % (component_name, attribute_name), json={"value": True}, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(self.client.get("attribute/%s/%s" % (component_name, attribute_name), headers=self.authorization_headers).content,
                         f"{{\"{component_name}.{attribute_name}\":true}}".encode())
        self.assertEqual(response.content, f"{{\"message\":\"Successfully changed attribute {attribute_name} of registered analysis component {component_name} to True\"}}".encode())
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        c = contentpy.replace(b'\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600\'"', f"\n    setattr(analysis_context.get_component_by_name(\"{component_name}\"), \"{attribute_name}\", True)\nconfig_properties[\\\"Core.PersistencePeriod\\\"] = 600".encode() + b'\'"')
        if self.dest_config_file.endswith(".yml"):
            c = contentyml.replace(b'- type: NewMatchPathValueComboDetector\\n          id: NewMatchPathValueCombo\\n          paths:\\n            - \\"/model/IPAddresses/Username\\"\\n            - \\"/model/IPAddresses/IP\\"\\n          learn_mode: False', b'- type: NewMatchPathValueComboDetector\\n          id: NewMatchPathValueCombo\\n          paths:\\n            - \\"/model/IPAddresses/Username\\"\\n            - \\"/model/IPAddresses/IP\\"\\n          learn_mode: True')
        self.assertEqual(new_live_config, c.decode("unicode-escape"))
        self.client.put("attribute/%s/%s" % (component_name, attribute_name), json={"value": False}, headers=self.authorization_headers)
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        c = contentpy.replace(b'\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600\'"', f"\n    setattr(analysis_context.get_component_by_name(\"{component_name}\"), \"{attribute_name}\", False)\nconfig_properties[\\\"Core.PersistencePeriod\\\"] = 600".encode() + b'\'"')
        if self.dest_config_file.endswith(".yml"):
            c = contentyml
        self.assertEqual(new_live_config, c.decode("unicode-escape"))

        response = self.client.put("attribute/%s/%s" % (component_name, attribute_name), json={"value": True})
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")

        response = self.client.put("attribute/%s/%s" % (component_name, attribute_name), json={"value": True}, headers={
            "Authorization": "%s %s" % (self.token_type, self.access_token + "failedtoken")})
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")

        response = self.client.put("attribute/%s/%s" % (component_name, attribute_name), json={"value": 2},
                                   headers=self.authorization_headers)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(self.client.get("attribute/%s/%s" % (component_name, attribute_name), headers=self.authorization_headers).content,
                         f"{{\"{component_name}.{attribute_name}\":false}}".encode())
        self.assertEqual(response.content, f'{{"detail":"property \'{component_name}.{attribute_name}\' must be of type {type(True)}!"}}'.encode())

        component_name = "NewMatchPathValueComboDetector"
        response = self.client.put("attribute/%s/%s" % (component_name, attribute_name), json={"value": True},
                                   headers=self.authorization_headers)
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f'{{"detail":"the component \'{component_name}\' does not exist."}}'.encode())

        component_name = "NewMatchPathValueCombo"
        attribute_name = "not_existing_attribute"
        response = self.client.get("attribute/%s/%s" % (component_name, attribute_name), headers=self.authorization_headers)
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f'{{"detail":"the component \'{component_name}\' does not have an attribute named \'{attribute_name}\'."}}'.encode())

        attribute_name = "learn_mode"
        response = self.client.put("attribute/%s/%s" % (component_name, attribute_name), json={"value": True},
                                   headers={"content-md5": "md5 string", **self.authorization_headers})
        self.assertEqual(response.status_code, 501)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f'{{"detail":"{ERR_HEADER_NOT_IMPLEMENTED % "content-md5"}"}}'.encode())

    def test5save_config(self):
        contentpy = b'from aminer.parsing.FirstMatchModelElement import FirstMatchModelElement\\nfrom aminer.parsing.SequenceModelElement import SequenceModelElement\\nfrom aminer.parsing.FixedDataModelElement import FixedDataModelElement\\nfrom aminer.parsing.DelimitedDataModelElement import DelimitedDataModelElement\\nfrom aminer.parsing.AnyByteDataModelElement import AnyByteDataModelElement\\nfrom aminer.parsing.FixedWordlistDataModelElement import FixedWordlistDataModelElement\\nfrom aminer.parsing.DecimalIntegerValueModelElement import DecimalIntegerValueModelElement\\nfrom aminer.parsing.DateTimeModelElement import DateTimeModelElement\\nfrom aminer.parsing.IpAddressDataModelElement import IpAddressDataModelElement\\nfrom aminer.parsing.OptionalMatchModelElement import OptionalMatchModelElement\\n\\n# This is a template for the \\"aminer\\" logfile miner tool. Copy\\n# it to \\"config.py\\" and define your ruleset.\\n\\nconfig_properties = {}\\n\\n# Define the list of log resources to read from: the resources\\n# named here do not need to exist when aminer is started. This\\n# will just result in a warning. However, if they exist, they have\\n# to be readable by the aminer process! Supported types are:\\n# * file://[path]: Read data from file, reopen it after rollover\\n# * unix://[path]: Open the path as UNIX local socket for reading\\n\\n# can not use unix socket for aminer-rest, because the socket needs to be open, while aminer-rest needs aminer running at startup.\\nconfig_properties[\'LogResourceList\'] = [\'file:///tmp/syslog\', \'file:///tmp/aminer-rest-input.log\']\\n\\n# Define the uid/gid of the process that runs the calculation\\n# after opening the log files:\\nconfig_properties[\'AminerUser\'] = \'aminer\'\\nconfig_properties[\'AminerGroup\'] = \'aminer\'\\n\\n# Define the path, where aminer will listen for incoming remote\\n# control connections. When missing, no remote control socket\\n# will be created.\\nconfig_properties[\'RemoteControlSocket\'] = \'/var/run/aminer-remote.socket\'\\n\\n# Read the analyis from this file. That part of configuration\\n# is separated from the main configuration so that it can be loaded\\n# only within the analysis child. Non-absolute path names are\\n# interpreted relatively to the main configuration file (this\\n# file). When empty, this configuration has to contain the configuration\\n# for the child also.\\n# config_properties[\'AnalysisConfigFile\'] = \'analysis.py\'\\n\\nconfig_properties[\'Core.LogDir\'] = \'/tmp/lib/aminer/log\'\\n# Read and store information to be used between multiple invocations\\n# of aminer in this directory. The directory must only be accessible\\n# to the \'AminerUser\' but not group/world readable. On violation,\\n# aminer will refuse to start. When undefined, \'/var/lib/aminer\'\\n# is used.\\nconfig_properties[\'Core.PersistenceDir\'] = \'/tmp/lib/aminer\'\\n\\n# Define a target e-mail address to send alerts to. When undefined,\\n# no e-mail notification hooks are added.\\nconfig_properties[\'MailAlerting.TargetAddress\'] = \'root@localhost\'\\n# Sender address of e-mail alerts. When undefined, \\"sendmail\\"\\n# implementation on host will decide, which sender address should\\n# be used.\\nconfig_properties[\'MailAlerting.FromAddress\'] = \'root@localhost\'\\n# Define, which text should be prepended to the standard aminer\\n# subject. Defaults to \\"aminer Alerts:\\"\\nconfig_properties[\'MailAlerting.SubjectPrefix\'] = \'aminer Alerts:\'\\n# Define a grace time after startup before aminer will react to\\n# an event and send the first alert e-mail. Defaults to 0 (any\\n# event can immediately trigger alerting).\\nconfig_properties[\'MailAlerting.AlertGraceTime\'] = 0\\n# Define how many seconds to wait after a first event triggered\\n# the alerting procedure before really sending out the e-mail.\\n# In that timespan, events are collected and will be sent all\\n# using a single e-mail. Defaults to 10 seconds.\\nconfig_properties[\'MailAlerting.EventCollectTime\'] = 0\\n# Define the minimum time between two alert e-mails in seconds\\n# to avoid spamming. All events during this timespan are collected\\n# and sent out with the next report. Defaults to 600 seconds.\\nconfig_properties[\'MailAlerting.MinAlertGap\'] = 0\\n# Define the maximum time between two alert e-mails in seconds.\\n# When undefined this defaults to \\"MailAlerting.MinAlertGap\\".\\n# Otherwise this will activate an exponential backoff to reduce\\n# messages during permanent error states by increasing the alert\\n# gap by 50% when more alert-worthy events were recorded while\\n# the previous gap time was not yet elapsed.\\nconfig_properties[\'MailAlerting.MaxAlertGap\'] = 600\\n# Define how many events should be included in one alert mail\\n# at most. This defaults to 1000\\nconfig_properties[\'MailAlerting.MaxEventsPerMessage\'] = 1000\\nconfig_properties[\'LogPrefix\'] = \'Original log line: \'\\n\\n# Add your ruleset here:\\n\\n\\ndef build_analysis_pipeline(analysis_context):\\n    \\"\\"\\"Define the function to create pipeline for parsing the log data.\\n\\n    It has also to define an AtomizerFactory to instruct aminer how to\\n    process incoming data streams to create log atoms from them.\\n    \\"\\"\\"\\n    # Build the parsing model:\\n\\n    service_children_disk_report = [\\n        FixedDataModelElement(\'Space\', b\' Current Disk Data is: Filesystem     Type  Size  Used Avail Use%\'),\\n        DelimitedDataModelElement(\'Data\', b\'%\'), AnyByteDataModelElement(\'Rest\')]\\n\\n    service_children_login_details = [\\n        FixedDataModelElement(\'User\', b\'User \'), DelimitedDataModelElement(\'Username\', b\' \'),\\n        FixedWordlistDataModelElement(\'Status\', [b\' logged in\', b\' logged out\']),\\n        OptionalMatchModelElement(\'PastTime\', SequenceModelElement(\'Time\', [\\n            FixedDataModelElement(\'Blank\', b\' \'), DecimalIntegerValueModelElement(\'Minutes\'),\\n            FixedDataModelElement(\'Ago\', b\' minutes ago.\')]))]\\n\\n    service_children_cron_job = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'UNameSpace1\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'UNameSpace2\', b\' \'), DelimitedDataModelElement(\'User\', b\' \'),\\n        FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Details\', b\']: Job `cron.daily` started.\')]\\n\\n    service_children_random_time = [FixedDataModelElement(\'Space\', b\'Random: \'), DecimalIntegerValueModelElement(\'Random\')]\\n\\n    service_children_sensors = [SequenceModelElement(\'CPUTemp\', [\\n        FixedDataModelElement(\'FixedTemp\', b\'CPU Temp: \'), DecimalIntegerValueModelElement(\'Temp\'),\\n        FixedDataModelElement(\'Degrees\', b\'\\\\xc2\\\\xb0C\')]), FixedDataModelElement(\'Space1\', b\', \'), SequenceModelElement(\'CPUWorkload\', [\\n            FixedDataModelElement(\'FixedWorkload\', b\'CPUWorkload: \'), DecimalIntegerValueModelElement(\'Workload\'),\\n            FixedDataModelElement(\'Percent\', b\'%\')]), FixedDataModelElement(\'Space2\', b\', \'),\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\')]\\n\\n    service_children_user_ip_address = [\\n        FixedDataModelElement(\'User\', b\'User \'), DelimitedDataModelElement(\'Username\', b\' \'),\\n        FixedDataModelElement(\'Action\', b\' changed IP address to \'), IpAddressDataModelElement(\'IP\')]\\n\\n    service_children_cron_job_announcement = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'Space\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Run\', b\']: Will run job `\'),\\n        FixedWordlistDataModelElement(\'CronType\', [b\'cron.daily\', b\'cron.hourly\', b\'cron.monthly\', b\'cron.weekly\']),\\n        FixedDataModelElement(\'StartTime\', b\'\\\\\' in 5 min.\')]\\n\\n    service_children_cron_job_execution = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'Space1\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Job\', b\']: Job `\'),\\n        FixedWordlistDataModelElement(\'CronType\', [b\'cron.daily\', b\'cron.hourly\', b\'cron.monthly\', b\'cron.weekly\']),\\n        FixedDataModelElement(\'Started\', b\'\\\\\' started\')]\\n\\n    parsing_model = FirstMatchModelElement(\'model\', [\\n        SequenceModelElement(\'CronAnnouncement\', service_children_cron_job_announcement),\\n        SequenceModelElement(\'CronExecution\', service_children_cron_job_execution),\\n        SequenceModelElement(\'DailyCron\', service_children_cron_job), SequenceModelElement(\'DiskReport\', service_children_disk_report),\\n        SequenceModelElement(\'LoginDetails\', service_children_login_details), DecimalIntegerValueModelElement(\'Random\'),\\n        SequenceModelElement(\'RandomTime\', service_children_random_time), SequenceModelElement(\'Sensors\', service_children_sensors),\\n        SequenceModelElement(\'IPAddresses\', service_children_user_ip_address)])\\n\\n    # Some generic imports.\\n    from aminer.analysis import AtomFilters\\n\\n    # Create all global handler lists here and append the real handlers later on.\\n    # Use this filter to distribute all atoms to the analysis handlers.\\n    atom_filters = AtomFilters.SubhandlerFilter(None)\\n    analysis_context.register_component(atom_filters, component_name=\\"AtomFilter\\")\\n\\n    from aminer.analysis.TimestampCorrectionFilters import SimpleMonotonicTimestampAdjust\\n    simple_monotonic_timestamp_adjust = SimpleMonotonicTimestampAdjust([atom_filters])\\n    analysis_context.register_component(simple_monotonic_timestamp_adjust, component_name=\\"SimpleMonotonicTimestampAdjust\\")\\n\\n    from aminer.events.StreamPrinterEventHandler import StreamPrinterEventHandler\\n    import os\\n    import stat\\n    stpe = StreamPrinterEventHandler(analysis_context)\\n    aminer_rest_output = \\"/tmp/aminer-rest-output.log\\"\\n    mode = \'w+\'\\n    if os.path.exists(aminer_rest_output) and stat.S_ISFIFO(os.stat(aminer_rest_output).st_mode):\\n        mode = \'w\'\\n    stream = open(aminer_rest_output, mode)\\n    aminer_rest_stpe = StreamPrinterEventHandler(analysis_context, stream)\\n    from aminer.events.JsonConverterHandler import JsonConverterHandler\\n    aminer_rest_jch = JsonConverterHandler([aminer_rest_stpe], analysis_context, pretty_print=False)\\n\\n    from aminer.events.Utils import VolatileLogarithmicBackoffEventHistory\\n    volatile_logarithmic_backoff_event_history = VolatileLogarithmicBackoffEventHistory(100)\\n    anomaly_event_handlers = [stpe, aminer_rest_jch, volatile_logarithmic_backoff_event_history]\\n    analysis_context.register_component(volatile_logarithmic_backoff_event_history, component_name=\\"VolatileLogarithmicBackoffEventHistory\\")\\n\\n    # Now define the AtomizerFactory using the model. A simple line based one is usually sufficient.\\n    from aminer.input.SimpleByteStreamLineAtomizerFactory import SimpleByteStreamLineAtomizerFactory\\n    analysis_context.atomizer_factory = SimpleByteStreamLineAtomizerFactory(\\n        parsing_model, [simple_monotonic_timestamp_adjust], anomaly_event_handlers, use_real_time=True)\\n\\n    # Just report all unparsed atoms to the event handlers.\\n    from aminer.analysis.UnparsedAtomHandlers import SimpleUnparsedAtomHandler\\n    simple_unparsed_atom_handler = SimpleUnparsedAtomHandler(anomaly_event_handlers)\\n    atom_filters.add_handler(simple_unparsed_atom_handler, stop_when_handled_flag=True)\\n    analysis_context.register_component(simple_unparsed_atom_handler, component_name=\\"UnparsedHandler\\")\\n\\n    from aminer.analysis.TimestampsUnsortedDetector import TimestampsUnsortedDetector\\n    timestamps_unsorted_detector = TimestampsUnsortedDetector(analysis_context.aminer_config, anomaly_event_handlers)\\n    atom_filters.add_handler(timestamps_unsorted_detector)\\n    analysis_context.register_component(timestamps_unsorted_detector, component_name=\\"TimestampsUnsortedDetector\\")\\n\\n    from aminer.analysis import Rules\\n    from aminer.analysis.AllowlistViolationDetector import AllowlistViolationDetector\\n    allowlist_rules = [\\n        Rules.OrMatchRule([\\n            Rules.AndMatchRule([\\n                Rules.PathExistsMatchRule(\'/model/LoginDetails/PastTime/Time/Minutes\'),\\n                Rules.NegationMatchRule(Rules.ValueMatchRule(\'/model/LoginDetails/Username\', b\'root\'))]),\\n            Rules.AndMatchRule([\\n                Rules.NegationMatchRule(Rules.PathExistsMatchRule(\'/model/LoginDetails/PastTime/Time/Minutes\')),\\n                Rules.PathExistsMatchRule(\'/model/LoginDetails\')]),\\n            Rules.NegationMatchRule(Rules.PathExistsMatchRule(\'/model/LoginDetails\'))])]\\n\\n    # This rule list should trigger, when the line does not look like: User root (logged in, logged out)\\n    # or User \'username\' (logged in, logged out) x minutes ago.\\n    allowlist_violation_detector = AllowlistViolationDetector(analysis_context.aminer_config, allowlist_rules, anomaly_event_handlers)\\n    analysis_context.register_component(allowlist_violation_detector, component_name=\\"Allowlist\\")\\n    atom_filters.add_handler(allowlist_violation_detector)\\n\\n    from aminer.analysis.ParserCount import ParserCount\\n    parser_count = ParserCount(analysis_context.aminer_config, None, anomaly_event_handlers, 10)\\n    analysis_context.register_component(parser_count, component_name=\\"ParserCount\\")\\n    atom_filters.add_handler(parser_count)\\n\\n    from aminer.analysis.EventCorrelationDetector import EventCorrelationDetector\\n    ecd = EventCorrelationDetector(analysis_context.aminer_config, anomaly_event_handlers, check_rules_flag=True,\\n                                   hypothesis_max_delta_time=1.0, learn_mode=True)\\n    analysis_context.register_component(ecd, component_name=\\"EventCorrelationDetector\\")\\n    atom_filters.add_handler(ecd)\\n\\n    from aminer.analysis.NewMatchPathDetector import NewMatchPathDetector\\n    new_match_path_detector = NewMatchPathDetector(analysis_context.aminer_config, anomaly_event_handlers, learn_mode=True)\\n    analysis_context.register_component(new_match_path_detector, component_name=\\"NewMatchPath\\")\\n    atom_filters.add_handler(new_match_path_detector)\\n\\n    def tuple_transformation_function(match_value_list):\\n        \\"\\"\\"Only allow output of the EnhancedNewMatchPathValueComboDetector\\n        after every 10000th element.\\"\\"\\"\\n        extra_data = enhanced_new_match_path_value_combo_detector.known_values_dict.get(tuple(match_value_list))\\n        if extra_data is not None:\\n            mod = 10000\\n            if (extra_data[2] + 1) % mod == 0:\\n                enhanced_new_match_path_value_combo_detector.learn_mode = False\\n            else:\\n                enhanced_new_match_path_value_combo_detector.learn_mode = True\\n        return match_value_list\\n\\n    from aminer.analysis.EnhancedNewMatchPathValueComboDetector import EnhancedNewMatchPathValueComboDetector\\n    enhanced_new_match_path_value_combo_detector = EnhancedNewMatchPathValueComboDetector(\\n        analysis_context.aminer_config, [\'/model/DailyCron/UName\', \'/model/DailyCron/JobNumber\'], anomaly_event_handlers,\\n        learn_mode=False, tuple_transformation_function=tuple_transformation_function)\\n    analysis_context.register_component(enhanced_new_match_path_value_combo_detector, component_name=\\"EnhancedNewValueCombo\\")\\n    atom_filters.add_handler(enhanced_new_match_path_value_combo_detector)\\n\\n    from aminer.analysis.HistogramAnalysis import HistogramAnalysis, LinearNumericBinDefinition, ModuloTimeBinDefinition, \\\\\\n        PathDependentHistogramAnalysis\\n    modulo_time_bin_definition = ModuloTimeBinDefinition(86400, 3600, 0, 1, 24, True)\\n    linear_numeric_bin_definition = LinearNumericBinDefinition(50, 5, 20, True)\\n    histogram_analysis = HistogramAnalysis(analysis_context.aminer_config, [\\n        (\'/model/RandomTime/Random\', modulo_time_bin_definition), (\'/model/Random\', linear_numeric_bin_definition)], 10,\\n        anomaly_event_handlers)\\n    analysis_context.register_component(histogram_analysis, component_name=\\"HistogramAnalysis\\")\\n    atom_filters.add_handler(histogram_analysis)\\n\\n    path_dependent_histogram_analysis = PathDependentHistogramAnalysis(analysis_context.aminer_config, \'/model/RandomTime\',\\n                                                                       modulo_time_bin_definition, 10, anomaly_event_handlers)\\n    analysis_context.register_component(path_dependent_histogram_analysis, component_name=\\"PathDependentHistogramAnalysis\\")\\n    atom_filters.add_handler(path_dependent_histogram_analysis)\\n\\n    from aminer.analysis.MatchValueAverageChangeDetector import MatchValueAverageChangeDetector\\n    match_value_average_change_detector = MatchValueAverageChangeDetector(analysis_context.aminer_config, anomaly_event_handlers, None,\\n                                                                          [\'/model/Random\'], 100, 10)\\n    analysis_context.register_component(match_value_average_change_detector, component_name=\\"MatchValueAverageChange\\")\\n    atom_filters.add_handler(match_value_average_change_detector)\\n\\n    import sys\\n    from aminer.analysis.MatchValueStreamWriter import MatchValueStreamWriter\\n    match_value_stream_writer = MatchValueStreamWriter(\\n        sys.stdout, [\'/model/Sensors/CPUTemp\', \'/model/Sensors/CPUWorkload\', \'/model/Sensors/DTM\'], b\';\', b\'\')\\n    analysis_context.register_component(match_value_stream_writer, component_name=\\"MatchValueStreamWriter\\")\\n    atom_filters.add_handler(match_value_stream_writer)\\n\\n    from aminer.analysis.NewMatchPathValueComboDetector import NewMatchPathValueComboDetector\\n    new_match_path_value_combo_detector = NewMatchPathValueComboDetector(analysis_context.aminer_config, [\\n        \'/model/IPAddresses/Username\', \'/model/IPAddresses/IP\'], anomaly_event_handlers, learn_mode=False)\\n    analysis_context.register_component(new_match_path_value_combo_detector, component_name=\\"NewMatchPathValueCombo\\")\\n    atom_filters.add_handler(new_match_path_value_combo_detector)\\n\\n    from aminer.analysis.NewMatchIdValueComboDetector import NewMatchIdValueComboDetector\\n    new_match_id_value_combo_detector = NewMatchIdValueComboDetector(\\n        analysis_context.aminer_config, [\'/model/type/path/id\', \'/model/type/syscall/id\'], anomaly_event_handlers,\\n        id_path_list=[\'/model/type/path/id\', \'/model/type/syscall/id\'], min_allowed_time_diff=5, learn_mode=True,\\n        allow_missing_values_flag=True, output_logline=True)\\n    analysis_context.register_component(new_match_id_value_combo_detector, component_name=\\"NewMatchIdValueComboDetector\\")\\n    atom_filters.add_handler(new_match_id_value_combo_detector)\\n\\n    from aminer.analysis.NewMatchPathValueDetector import NewMatchPathValueDetector\\n    new_match_path_value_detector = NewMatchPathValueDetector(analysis_context.aminer_config, [\\n        \'/model/DailyCron/Job Number\', \'/model/IPAddresses/Username\'], anomaly_event_handlers, learn_mode=False)\\n    analysis_context.register_component(new_match_path_value_detector, component_name=\\"NewMatchPathValue\\")\\n    atom_filters.add_handler(new_match_path_value_detector)\\n\\n    from aminer.analysis.MissingMatchPathValueDetector import MissingMatchPathValueDetector\\n    missing_match_path_value_detector = MissingMatchPathValueDetector(\\n        analysis_context.aminer_config, [\'/model/DiskReport/Space\'], anomaly_event_handlers, learn_mode=False, default_interval=2,\\n        realert_interval=5)\\n    analysis_context.register_component(missing_match_path_value_detector, component_name=\\"MissingMatch\\")\\n    atom_filters.add_handler(missing_match_path_value_detector)\\n\\n    from aminer.analysis.TimeCorrelationDetector import TimeCorrelationDetector\\n    time_correlation_detector = TimeCorrelationDetector(\\n        analysis_context.aminer_config, anomaly_event_handlers, 2, min_rule_attributes=1, max_rule_attributes=5,\\n        record_count_before_event=70000, output_logline=True)\\n    analysis_context.register_component(time_correlation_detector, component_name=\\"TimeCorrelationDetector\\")\\n    atom_filters.add_handler(time_correlation_detector)\\n\\n    from aminer.analysis.TimeCorrelationViolationDetector import TimeCorrelationViolationDetector, CorrelationRule, EventClassSelector\\n    cron_job_announcement = CorrelationRule(\'CronJobAnnouncement\', 5, 6, artefact_match_parameters=[\\n        (\'/model/CronAnnouncement/JobNumber\', \'/model/CronExecution/JobNumber\')])\\n    a_class_selector = EventClassSelector(\'Announcement\', [cron_job_announcement], None)\\n    b_class_selector = EventClassSelector(\'Execution\', None, [cron_job_announcement])\\n    rules = [Rules.PathExistsMatchRule(\'/model/CronAnnouncement/Run\', a_class_selector),\\n             Rules.PathExistsMatchRule(\'/model/CronExecution/Job\', b_class_selector)]\\n\\n    time_correlation_violation_detector = TimeCorrelationViolationDetector(analysis_context.aminer_config, rules, anomaly_event_handlers)\\n    analysis_context.register_component(time_correlation_violation_detector, component_name=\\"TimeCorrelationViolationDetector\\")\\n    atom_filters.add_handler(time_correlation_violation_detector)\\n\\n    from aminer.events.DefaultMailNotificationEventHandler import DefaultMailNotificationEventHandler\\n    if DefaultMailNotificationEventHandler.CONFIG_KEY_MAIL_TARGET_ADDRESS in analysis_context.aminer_config.config_properties:\\n        mail_notification_handler = DefaultMailNotificationEventHandler(analysis_context)\\n        analysis_context.register_component(mail_notification_handler, component_name=\\"MailHandler\\")\\n        anomaly_event_handlers.append(mail_notification_handler)\\n\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600'
        contentyml = b'LearnMode: False\\n\\nCore.LogDir: \'/tmp/lib/aminer/log\'\\n\\nCore.PersistenceDir: \'/tmp/lib/aminer\'\\n\\nCore.PersistencePeriod: 600\\n\\n# can not use unix socket for aminer-rest, because the socket needs to be open, while aminer-rest needs aminer running at startup.\\nLogResourceList:\\n        - \'file:///tmp/syslog\'\\n        - \'file:///tmp/aminer-rest-input.log\'\\n\\nRemoteControlSocket: \'/var/run/aminer-remote.socket\'\\n\\nMailAlerting.TargetAddress: \'root@localhost\'\\n\\nMailAlerting.FromAddress: \'root@localhost\'\\n\\nMailAlerting.SubjectPrefix: \'aminer Alerts:\'\\n\\nMailAlerting.AlertGraceTime: 0\\n\\nMailAlerting.EventCollectTime: 0\\n\\nMailAlerting.MinAlertGap: 0\\n\\nMailAlerting.MaxAlertGap: 600\\n\\nMailAlerting.MaxEventsPerMessage: 1000\\n\\nLogPrefix: \'Original log line: \'\\n\\nAminerId: \'demo-aminer\'\\n\\nParser:\\n       - id: space\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \' Current Disk Data is: Filesystem     Type  Size  Used Avail Use%\'\\n\\n       - id: data\\n         type: DelimitedDataModelElement\\n         name: \'Data\'\\n         delimiter: \'%\'\'/\'\\n\\n       - id: rest\\n         type: AnyByteDataModelElement\\n         name: \'Rest\'\\n\\n       - id: userLoginDetails\\n         type: FixedDataModelElement\\n         name: \'User\'\\n         args: \'User \'\\n\\n       - id: userIpAddress\\n         type: FixedDataModelElement\\n         name: \'User\'\\n         args: \'User \'\\n\\n       - id: username\\n         type: DelimitedDataModelElement\\n         name: \'Username\'\\n         delimiter: \' \'\\n\\n       - id: status\\n         type: FixedWordlistDataModelElement\\n         name: \'Status\'\\n         args:\\n           - \' logged in\'\\n           - \' logged out\'\\n\\n       - id: blank\\n         type: FixedDataModelElement\\n         name: \'Blank\'\\n         args: \' \'\\n\\n       - id: minutes\\n         type: DecimalIntegerValueModelElement\\n         name: \'Minutes\'\\n\\n       - id: ago\\n         type: FixedDataModelElement\\n         name: \'Ago\'\\n         args: \' minutes ago.\'\\n\\n       - id: time\\n         type: SequenceModelElement\\n         name: \'Time\'\\n         args:\\n           - blank\\n           - minutes\\n           - ago\\n\\n       - id: pastTime\\n         type: OptionalMatchModelElement\\n         name: \'PastTime\'\\n         args: time\\n\\n       - id: dtm\\n         type: DateTimeModelElement\\n         name: \'DTM\'\\n         date_format: \'%Y-%m-%d %H:%M:%S\'\\n         start_year: null\\n         text_locale: null\\n         max_time_jump_seconds: 86400\\n\\n       - id: uNameSpace1\\n         type: FixedDataModelElement\\n         name: \'UNameSpace1\'\\n         args: \' \'\\n\\n       - id: uName\\n         type: DelimitedDataModelElement\\n         name: \'UName\'\\n         delimiter: \' \'\\n\\n       - id: uNameSpace2\\n         type: FixedDataModelElement\\n         name: \'UNameSpace2\'\\n         args: \' \'\\n\\n       - id: delimitedUser\\n         type: DelimitedDataModelElement\\n         name: \'User\'\\n         delimiter: \' \'\\n\\n       - id: cron\\n         type: FixedDataModelElement\\n         name: \'Cron\'\\n         args: \' cron[\'\\n\\n       - id: jobNumber\\n         type: DecimalIntegerValueModelElement\\n         name: \'JobNumber\'\\n\\n       - id: details\\n         type: FixedDataModelElement\\n         name: \'Details\'\\n         args: \']: Job `cron.daily` started.\'\\n\\n       - id: spaceRandom\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \'Random: \'\\n\\n       - id: random\\n         type: DecimalIntegerValueModelElement\\n         name: \'Random\'\\n\\n       - id: fixedTemp\\n         type: FixedDataModelElement\\n         name: \'FixedTemp\'\\n         args: \'CPU Temp: \'\\n\\n       - id: temp\\n         type: DecimalIntegerValueModelElement\\n         name: \'Temp\'\\n\\n       - id: degrees\\n         type: FixedDataModelElement\\n         name: \'Degrees\'\\n         args: \'\xc2\xb0C\'\\n\\n       - id: cpuTemp\\n         type: SequenceModelElement\\n         name: \'CPUTemp\'\\n         args:\\n           - fixedTemp\\n           - temp\\n           - degrees\\n\\n       - id: space1\\n         type: FixedDataModelElement\\n         name: \'Space1\'\\n         args: \', \'\\n\\n       - id: fixedWorkload\\n         type: FixedDataModelElement\\n         name: \'FixedWorkload\'\\n         args: \'CPU Workload: \'\\n\\n       - id: workload\\n         type: DecimalIntegerValueModelElement\\n         name: \'Workload\'\\n\\n       - id: percent\\n         type: FixedDataModelElement\\n         name: \'Percent\'\\n         args: \'%\'\\n\\n       - id: cpuWorkload\\n         type: SequenceModelElement\\n         name: \'CPUWorkload\'\\n         args:\\n           - fixedWorkload\\n           - workload\\n           - percent\\n\\n       - id: space2\\n         type: FixedDataModelElement\\n         name: \'Space2\'\\n         args: \', \'\\n\\n       - id: action\\n         type: FixedDataModelElement\\n         name: \'Action\'\\n         args: \' changed IP address to \'\\n\\n       - id: ip\\n         type: IpAddressDataModelElement\\n         name: \'IP\'\\n\\n       - id: fixedSpace\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \' \'\\n\\n       - id: run\\n         type: FixedDataModelElement\\n         name: \'Run\'\\n         args: \']: Will run job `\'\\n\\n       - id: cronType\\n         type: FixedWordlistDataModelElement\\n         name: \'CronType\'\\n         args:\\n           - \'cron.daily\'\\n           - \'cron.hourly\'\\n           - \'cron.monthly\'\\n           - \'cron.weekly\'\\n\\n       - id: startTime\\n         type: FixedDataModelElement\\n         name: \'StartTime\'\\n         args: \\"\' in 5 min.\\"\\n\\n       - id: emptySpace1\\n         type: FixedDataModelElement\\n         name: \'Space1\'\\n         args: \' \'\\n\\n       - id: job\\n         type: FixedDataModelElement\\n         name: \'Job\'\\n         args: \']: Job `\'\\n\\n       - id: started\\n         type: FixedDataModelElement\\n         name: \'Started\'\\n         args: \\"\' started\\"\\n\\n       - id: cronAnnouncement\\n         type: SequenceModelElement\\n         name: \'CronAnnouncement\'\\n         args:\\n           - dtm\\n           - fixedSpace\\n           - uName\\n           - cron\\n           - jobNumber\\n           - run\\n           - cronType\\n           - startTime\\n\\n       - id: cronExecution\\n         type: SequenceModelElement\\n         name: \'CronExecution\'\\n         args:\\n           - dtm\\n           - emptySpace1\\n           - uName\\n           - cron\\n           - jobNumber\\n           - job\\n           - cronType\\n           - started\\n\\n       - id: dailyCron\\n         type: SequenceModelElement\\n         name: \'DailyCron\'\\n         args:\\n           - dtm\\n           - uNameSpace1\\n           - uName\\n           - uNameSpace2\\n           - delimitedUser\\n           - cron\\n           - jobNumber\\n           - details\\n\\n       - id: diskReport\\n         type: SequenceModelElement\\n         name: \'DiskReport\'\\n         args:\\n           - space\\n           - data\\n           - rest\\n\\n       - id: loginDetails\\n         type: SequenceModelElement\\n         name: \'LoginDetails\'\\n         args:\\n           - userLoginDetails\\n           - username\\n           - status\\n           - pastTime\\n\\n       - id: randomTime\\n         type: SequenceModelElement\\n         name: \'RandomTime\'\\n         args:\\n           - spaceRandom\\n           - random\\n\\n       - id: sensors\\n         type: SequenceModelElement\\n         name: \'Sensors\'\\n         args:\\n           - cpuTemp\\n           - space1\\n           - cpuWorkload\\n           - space2\\n           - dtm\\n\\n       - id: ipAddresses\\n         type: SequenceModelElement\\n         name: \'IPAddresses\'\\n         args:\\n           - userIpAddress\\n           - username\\n           - action\\n           - ip\\n\\n       - id: model\\n         start: True\\n         type: FirstMatchModelElement\\n         name: \'model\'\\n         args:\\n           - cronAnnouncement\\n           - cronExecution\\n           - dailyCron\\n           - diskReport\\n           - loginDetails\\n           - random\\n           - randomTime\\n           - sensors\\n           - ipAddresses\\n\\nInput:\\n        timestamp_paths: [\\"/model/DailyCron/DTM\\"]\\n        adjust_timestamps: True\\n        use_real_time: True\\n\\nAnalysis:\\n        - type: TimestampsUnsortedDetector\\n          id: TimestampsUnsortedDetector\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule1\\n          path: \\"/model/LoginDetails/PastTime/Time/Minutes\\"\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule2\\n          path: \\"/model/LoginDetails\\"\\n        - type: ValueMatchRule\\n          id: value_match_rule\\n          path: \\"/model/LoginDetails/Username\\"\\n          value: \\"root\\"\\n        - type: NegationMatchRule\\n          id: negation_match_rule1\\n          sub_rule: \\"value_match_rule\\"\\n        - type: NegationMatchRule\\n          id: negation_match_rule2\\n          sub_rule: \\"path_exists_match_rule2\\"\\n        - type: AndMatchRule\\n          id: and_match_rule1\\n          sub_rules:\\n            - \\"path_exists_match_rule1\\"\\n            - \\"negation_match_rule1\\"\\n        - type: AndMatchRule\\n          id: and_match_rule2\\n          sub_rules:\\n            - \\"negation_match_rule1\\"\\n            - \\"path_exists_match_rule2\\"\\n        - type: OrMatchRule\\n          id: or_match_rule\\n          sub_rules:\\n            - \\"and_match_rule1\\"\\n            - \\"and_match_rule2\\"\\n            - \\"negation_match_rule2\\"\\n        - type: AllowlistViolationDetector\\n          id: Allowlist\\n          allowlist_rules:\\n            - \\"or_match_rule\\"\\n        - type: ParserCount\\n          id: ParserCount\\n          report_interval: 10\\n        - type: MatchFilter\\n          id: MatchFilter\\n          paths:\\n            - \\"/model/Random\\"\\n          value_list:\\n            - 1\\n            - 10\\n            - 100\\n        - type: EnhancedNewMatchPathValueComboDetector\\n          id: EnhancedNewValueCombo\\n          paths:\\n            - \\"/model/DailyCron/UName\\"\\n            - \\"/model/DailyCron/JobNumber\\"\\n          tuple_transformation_function: \\"demo\\"\\n          learn_mode: True\\n        - type: ModuloTimeMatchRule\\n          id: \\"mt\\"\\n          path: \\"mtmr\\"\\n          seconds_modulo: 3\\n          lower_limit: 0\\n          upper_limit: 3\\n        - type: ValueDependentModuloTimeMatchRule\\n          id: \\"vdmt\\"\\n          path: \\"vdmtmr\\"\\n          seconds_modulo: 3\\n          paths:\\n            - \\"/model/ECD/g\\"\\n            - \\"/model/ECD/h\\"\\n            - \\"/model/ECD/i\\"\\n            - \\"/model/ECD/j\\"\\n            - \\"/model/ECD/k\\"\\n            - \\"/model/ECD/l\\"\\n          limit_lookup_dict:\\n            e:\\n              - 0\\n              - 2.95\\n          default_limit:\\n            - 0\\n            - 3\\n        - type: ValueDependentDelegatedMatchRule\\n          id: \\"value_dependent_delegated_match_rule\\"\\n          paths:\\n            - \\"/model/ECD/g\\"\\n            - \\"/model/ECD/h\\"\\n            - \\"/model/ECD/i\\"\\n            - \\"/model/ECD/j\\"\\n            - \\"/model/ECD/k\\"\\n            - \\"/model/ECD/l\\"\\n          rule_lookup_dict:\\n            (b\\"g\\",): \\"mt\\"\\n            (b\\"h\\",): \\"mt\\"\\n            (b\\"i\\",): \\"mt\\"\\n            (b\\"j\\",): \\"vdmt\\"\\n            (b\\"k\\",): \\"vdmt\\"\\n            (b\\"l\\",): \\"vdmt\\"\\n          default_rule: \\"mt\\"\\n        - type: EventGenerationMatchAction\\n          id: \\"ip_match_action\\"\\n          event_type: \\"Analysis.Rules.IPv4InRFC1918MatchRule\\"\\n          event_message: \\"Private IP address occurred!\\"\\n        - type: IPv4InRFC1918MatchRule\\n          id: \\"ipv4_in_rfc1918_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          match_action: \\"ip_match_action\\"\\n        - type: DebugHistoryMatchRule\\n          id: \\"debug_history_match_rule\\"\\n          debug_mode: True\\n        - type: ValueListMatchRule\\n          id: \\"value_list_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          value_list:\\n            - 134744072\\n            - 134743044\\n        - type: NegationMatchRule\\n          id: \\"negation_list\\"\\n          sub_rule: \\"value_list_match_rule\\"\\n        - type: ValueRangeMatchRule\\n          id: \\"value_range_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          lower_limit: 167772160\\n          upper_limit: 184549375\\n        - type: NegationMatchRule\\n          id: \\"negation_range\\"\\n          sub_rule: \\"value_range_match_rule\\"\\n        - type: StringRegexMatchRule\\n          id: \\"string_regex_match_rule\\"\\n          path: \\"/model/type/syscall/success\\"\\n          regex: \\"^no$\\"\\n        - type: NegationMatchRule\\n          id: \\"negation_string_regex\\"\\n          sub_rule: \\"string_regex_match_rule\\"\\n        - type: ParallelMatchRule\\n          id: \\"parallel_match_rule\\"\\n          sub_rules:\\n            - \\"value_dependent_delegated_match_rule\\"\\n            - \\"ipv4_in_rfc1918_match_rule\\"\\n            - \\"debug_history_match_rule\\"\\n        - type: AndMatchRule\\n          id: \\"time_and_match_rule\\"\\n          sub_rules:\\n            - \\"parallel_match_rule\\"\\n            - \\"negation_list\\"\\n            - \\"negation_range\\"\\n            - \\"negation_string_regex\\"\\n        - type: AllowlistViolationDetector\\n          id: TimeAllowlist\\n          allowlist_rules:\\n            - \\"time_and_match_rule\\"\\n        - type: LinearNumericBinDefinition\\n          id: linear_numeric_bin_definition\\n          lower_limit: 50\\n          bin_size: 5\\n          bin_count: 20\\n          outlier_bins_flag: True\\n        - type: ModuloTimeBinDefinition\\n          id: modulo_time_bin_definition\\n          modulo_value: 86400\\n          time_unit: 3600\\n          lower_limit: 0\\n          bin_size: 1\\n          bin_count: 24\\n          outlier_bins_flag: True\\n        - type: HistogramAnalysis\\n          id: HistogramAnalysis\\n          histogram_defs: [[\\"/model/RandomTime/Random\\", \\"linear_numeric_bin_definition\\"]]\\n          report_interval: 10\\n        - type: PathDependentHistogramAnalysis\\n          id: PathDependentHistogramAnalysis\\n          path: \\"/model/RandomTime\\"\\n          bin_definition: \\"modulo_time_bin_definition\\"\\n          report_interval: 10\\n        - type: MatchValueAverageChangeDetector\\n          id: MatchValueAverageChange\\n          timestamp_path: null\\n          paths:\\n            - \\"/model/Random\\"\\n          min_bin_elements: 100\\n          min_bin_time: 10\\n        - type: MatchValueStreamWriter\\n          id: MatchValueStreamWriter\\n          stream: \\"sys.stdout\\"\\n          paths:\\n            - \\"/model/Sensors/CPUTemp\\"\\n            - \\"/model/Sensors/CPUWorkload\\"\\n            - \\"/model/Sensors/DTM\\"\\n          separator: \\";\\"\\n          missing_value_string: \\"\\"\\n        - type: NewMatchPathValueComboDetector\\n          id: NewMatchPathValueCombo\\n          paths:\\n            - \\"/model/IPAddresses/Username\\"\\n            - \\"/model/IPAddresses/IP\\"\\n          learn_mode: False\\n          log_resource_ignore_list:\\n            - \'file:///tmp/other_syslog\'\\n        - type: NewMatchIdValueComboDetector\\n          id: NewMatchIdValueComboDetector\\n          paths:\\n            - \\"/model/type/path/name\\"\\n            - \\"/model/type/syscall/syscall\\"\\n          id_path_list:\\n            - \\"/model/type/path/id\\"\\n            - \\"/model/type/syscall/id\\"\\n          min_allowed_time_diff: 5\\n          allow_missing_values: True\\n          learn_mode: True\\n        - type: NewMatchPathValueDetector\\n          id: NewMatchPathValue\\n          paths:\\n            - \\"/model/DailyCron/JobNumber\\"\\n            - \\"/model/IPAddresses/Username\\"\\n          learn_mode: True\\n        - type: MissingMatchPathValueDetector\\n          id: MissingMatch\\n          paths:\\n            - \\"/model/DiskReport/Space\\"\\n          check_interval: 2\\n          realert_interval: 5\\n          learn_mode: True\\n        - type: TimeCorrelationDetector\\n          id: TimeCorrelationDetector\\n          parallel_check_count: 2\\n          min_rule_attributes: 1\\n          max_rule_attributes: 5\\n          record_count_before_event: 10000\\n        - type: CorrelationRule\\n          rule_id: correlation_rule\\n          min_time_delta: 5\\n          max_time_delta: 6\\n          artefact_match_parameters: [[\\"/model/CronAnnouncement/JobNumber\\", \\"/model/CronExecution/JobNumber\\"]]\\n        - type: EventClassSelector\\n          action_id: a_class_selector\\n          artefact_a_rules:\\n            - correlation_rule\\n        - type: EventClassSelector\\n          action_id: b_class_selector\\n          artefact_b_rules:\\n            - correlation_rule\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule3\\n          path: \\"/model/CronAnnouncement/Run\\"\\n          match_action: a_class_selector\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule4\\n          path: \\"/model/CronExecution/Job\\"\\n          match_action: b_class_selector\\n        - type: TimeCorrelationViolationDetector\\n          id: TimeCorrelationViolationDetector\\n          ruleset:\\n            - path_exists_match_rule3\\n            - path_exists_match_rule4\\n\\nEventHandlers:\\n        - id: stpe\\n          type: StreamPrinterEventHandler\\n\\n        - id: aminer-rest-stpe\\n          type: StreamPrinterEventHandler\\n          json: True\\n          output_file_path: /tmp/aminer-rest-output.log\\n'
        component_name = "NewMatchPathValueCombo"
        attribute_name = "learn_mode"
        response = self.client.get("save_config", headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.headers["location"], self.dest_config_file)
        c = contentpy.replace(b'\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600', f"\\n    setattr(analysis_context.get_component_by_name(\\\"{component_name}\\\"), \\\"{attribute_name}\\\", False)\\nconfig_properties[\\\"Core.PersistencePeriod\\\"] = 600".encode())
        if self.dest_config_file.endswith(".yml"):
            c = contentyml
        self.assertEqual(response.content, f"{{\"filename\":\"{self.dest_config_file}\",\"content\":\"{c.decode()}\"}}".encode())

        # change values
        property_name = "Core.PersistencePeriod"
        self.client.put("config_property/%s" % property_name, json={"value": 700}, headers=self.authorization_headers)
        property_name = "MailAlerting.MaxEventsPerMessage"
        self.client.put("config_property/%s" % property_name, json={"value": 2}, headers=self.authorization_headers)
        self.client.put("attribute/%s/%s" % (component_name, attribute_name), json={"value": True}, headers=self.authorization_headers)

        response = self.client.get("save_config", headers=self.authorization_headers)
        c = contentpy.replace(b'\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600', f"\\n    setattr(analysis_context.get_component_by_name(\\\"{component_name}\\\"), \\\"{attribute_name}\\\", True)\\nconfig_properties[\\\"Core.PersistencePeriod\\\"] = 600".encode()).replace(b'Core.PersistencePeriod\\"] = 600', b'Core.PersistencePeriod\\"] = 700').replace(b"MailAlerting.MaxEventsPerMessage'] = 1000", b"MailAlerting.MaxEventsPerMessage'] = 2")
        if self.dest_config_file.endswith(".yml"):
            c = contentyml.replace(b'Core.PersistencePeriod: 600', b'Core.PersistencePeriod: 700').replace(b"MailAlerting.MaxEventsPerMessage: 1000", b"MailAlerting.MaxEventsPerMessage: 2").replace(b'- type: NewMatchPathValueComboDetector\\n          id: NewMatchPathValueCombo\\n          paths:\\n            - \\"/model/IPAddresses/Username\\"\\n            - \\"/model/IPAddresses/IP\\"\\n          learn_mode: False', b'- type: NewMatchPathValueComboDetector\\n          id: NewMatchPathValueCombo\\n          paths:\\n            - \\"/model/IPAddresses/Username\\"\\n            - \\"/model/IPAddresses/IP\\"\\n          learn_mode: True')
        self.assertEqual(response.content, f"{{\"filename\":\"{self.dest_config_file}\",\"content\":\"{c.decode()}\"}}".encode())

        # reset values
        property_name = "Core.PersistencePeriod"
        self.client.put("config_property/%s" % property_name, json={"value": 600}, headers=self.authorization_headers)
        property_name = "MailAlerting.MaxEventsPerMessage"
        self.client.put("config_property/%s" % property_name, json={"value": 1000}, headers=self.authorization_headers)
        component_name = "NewMatchPathValueCombo"
        attribute_name = "learn_mode"
        self.client.put("attribute/%s/%s" % (component_name, attribute_name), json={"value": False}, headers=self.authorization_headers)

        c = contentpy.replace(b'\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600', f"\\n    setattr(analysis_context.get_component_by_name(\\\"{component_name}\\\"), \\\"{attribute_name}\\\", False)\\nconfig_properties[\\\"Core.PersistencePeriod\\\"] = 600".encode())
        if self.dest_config_file.endswith(".yml"):
            c = contentyml
        response = self.client.get("save_config", headers=self.authorization_headers)
        self.assertEqual(response.content, f"{{\"filename\":\"{self.dest_config_file}\",\"content\":\"{c.decode()}\"}}".encode())

        response = self.client.get("save_config")
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")

        response = self.client.get("save_config", headers={
            "Authorization": "%s %s" % (self.token_type, self.access_token + "failedtoken")})
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")
        os.remove(self.dest_config_file)

    def test6rename_registered_analysis_component(self):
        contentpy = b'"Remote execution response: \'from aminer.parsing.FirstMatchModelElement import FirstMatchModelElement\\nfrom aminer.parsing.SequenceModelElement import SequenceModelElement\\nfrom aminer.parsing.FixedDataModelElement import FixedDataModelElement\\nfrom aminer.parsing.DelimitedDataModelElement import DelimitedDataModelElement\\nfrom aminer.parsing.AnyByteDataModelElement import AnyByteDataModelElement\\nfrom aminer.parsing.FixedWordlistDataModelElement import FixedWordlistDataModelElement\\nfrom aminer.parsing.DecimalIntegerValueModelElement import DecimalIntegerValueModelElement\\nfrom aminer.parsing.DateTimeModelElement import DateTimeModelElement\\nfrom aminer.parsing.IpAddressDataModelElement import IpAddressDataModelElement\\nfrom aminer.parsing.OptionalMatchModelElement import OptionalMatchModelElement\\n\\n# This is a template for the \\"aminer\\" logfile miner tool. Copy\\n# it to \\"config.py\\" and define your ruleset.\\n\\nconfig_properties = {}\\n\\n# Define the list of log resources to read from: the resources\\n# named here do not need to exist when aminer is started. This\\n# will just result in a warning. However, if they exist, they have\\n# to be readable by the aminer process! Supported types are:\\n# * file://[path]: Read data from file, reopen it after rollover\\n# * unix://[path]: Open the path as UNIX local socket for reading\\n\\n# can not use unix socket for aminer-rest, because the socket needs to be open, while aminer-rest needs aminer running at startup.\\nconfig_properties[\'LogResourceList\'] = [\'file:///tmp/syslog\', \'file:///tmp/aminer-rest-input.log\']\\n\\n# Define the uid/gid of the process that runs the calculation\\n# after opening the log files:\\nconfig_properties[\'AminerUser\'] = \'aminer\'\\nconfig_properties[\'AminerGroup\'] = \'aminer\'\\n\\n# Define the path, where aminer will listen for incoming remote\\n# control connections. When missing, no remote control socket\\n# will be created.\\nconfig_properties[\'RemoteControlSocket\'] = \'/var/run/aminer-remote.socket\'\\n\\n# Read the analyis from this file. That part of configuration\\n# is separated from the main configuration so that it can be loaded\\n# only within the analysis child. Non-absolute path names are\\n# interpreted relatively to the main configuration file (this\\n# file). When empty, this configuration has to contain the configuration\\n# for the child also.\\n# config_properties[\'AnalysisConfigFile\'] = \'analysis.py\'\\n\\nconfig_properties[\'Core.LogDir\'] = \'/tmp/lib/aminer/log\'\\n# Read and store information to be used between multiple invocations\\n# of aminer in this directory. The directory must only be accessible\\n# to the \'AminerUser\' but not group/world readable. On violation,\\n# aminer will refuse to start. When undefined, \'/var/lib/aminer\'\\n# is used.\\nconfig_properties[\'Core.PersistenceDir\'] = \'/tmp/lib/aminer\'\\n\\n# Define a target e-mail address to send alerts to. When undefined,\\n# no e-mail notification hooks are added.\\nconfig_properties[\'MailAlerting.TargetAddress\'] = \'root@localhost\'\\n# Sender address of e-mail alerts. When undefined, \\"sendmail\\"\\n# implementation on host will decide, which sender address should\\n# be used.\\nconfig_properties[\'MailAlerting.FromAddress\'] = \'root@localhost\'\\n# Define, which text should be prepended to the standard aminer\\n# subject. Defaults to \\"aminer Alerts:\\"\\nconfig_properties[\'MailAlerting.SubjectPrefix\'] = \'aminer Alerts:\'\\n# Define a grace time after startup before aminer will react to\\n# an event and send the first alert e-mail. Defaults to 0 (any\\n# event can immediately trigger alerting).\\nconfig_properties[\'MailAlerting.AlertGraceTime\'] = 0\\n# Define how many seconds to wait after a first event triggered\\n# the alerting procedure before really sending out the e-mail.\\n# In that timespan, events are collected and will be sent all\\n# using a single e-mail. Defaults to 10 seconds.\\nconfig_properties[\'MailAlerting.EventCollectTime\'] = 0\\n# Define the minimum time between two alert e-mails in seconds\\n# to avoid spamming. All events during this timespan are collected\\n# and sent out with the next report. Defaults to 600 seconds.\\nconfig_properties[\'MailAlerting.MinAlertGap\'] = 0\\n# Define the maximum time between two alert e-mails in seconds.\\n# When undefined this defaults to \\"MailAlerting.MinAlertGap\\".\\n# Otherwise this will activate an exponential backoff to reduce\\n# messages during permanent error states by increasing the alert\\n# gap by 50% when more alert-worthy events were recorded while\\n# the previous gap time was not yet elapsed.\\nconfig_properties[\'MailAlerting.MaxAlertGap\'] = 600\\n# Define how many events should be included in one alert mail\\n# at most. This defaults to 1000\\nconfig_properties[\'MailAlerting.MaxEventsPerMessage\'] = 1000\\nconfig_properties[\'LogPrefix\'] = \'Original log line: \'\\n\\n# Add your ruleset here:\\n\\n\\ndef build_analysis_pipeline(analysis_context):\\n    \\"\\"\\"Define the function to create pipeline for parsing the log data.\\n\\n    It has also to define an AtomizerFactory to instruct aminer how to\\n    process incoming data streams to create log atoms from them.\\n    \\"\\"\\"\\n    # Build the parsing model:\\n\\n    service_children_disk_report = [\\n        FixedDataModelElement(\'Space\', b\' Current Disk Data is: Filesystem     Type  Size  Used Avail Use%\'),\\n        DelimitedDataModelElement(\'Data\', b\'%\'), AnyByteDataModelElement(\'Rest\')]\\n\\n    service_children_login_details = [\\n        FixedDataModelElement(\'User\', b\'User \'), DelimitedDataModelElement(\'Username\', b\' \'),\\n        FixedWordlistDataModelElement(\'Status\', [b\' logged in\', b\' logged out\']),\\n        OptionalMatchModelElement(\'PastTime\', SequenceModelElement(\'Time\', [\\n            FixedDataModelElement(\'Blank\', b\' \'), DecimalIntegerValueModelElement(\'Minutes\'),\\n            FixedDataModelElement(\'Ago\', b\' minutes ago.\')]))]\\n\\n    service_children_cron_job = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'UNameSpace1\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'UNameSpace2\', b\' \'), DelimitedDataModelElement(\'User\', b\' \'),\\n        FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Details\', b\']: Job `cron.daily` started.\')]\\n\\n    service_children_random_time = [FixedDataModelElement(\'Space\', b\'Random: \'), DecimalIntegerValueModelElement(\'Random\')]\\n\\n    service_children_sensors = [SequenceModelElement(\'CPUTemp\', [\\n        FixedDataModelElement(\'FixedTemp\', b\'CPU Temp: \'), DecimalIntegerValueModelElement(\'Temp\'),\\n        FixedDataModelElement(\'Degrees\', b\'\\\\xc2\\\\xb0C\')]), FixedDataModelElement(\'Space1\', b\', \'), SequenceModelElement(\'CPUWorkload\', [\\n            FixedDataModelElement(\'FixedWorkload\', b\'CPUWorkload: \'), DecimalIntegerValueModelElement(\'Workload\'),\\n            FixedDataModelElement(\'Percent\', b\'%\')]), FixedDataModelElement(\'Space2\', b\', \'),\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\')]\\n\\n    service_children_user_ip_address = [\\n        FixedDataModelElement(\'User\', b\'User \'), DelimitedDataModelElement(\'Username\', b\' \'),\\n        FixedDataModelElement(\'Action\', b\' changed IP address to \'), IpAddressDataModelElement(\'IP\')]\\n\\n    service_children_cron_job_announcement = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'Space\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Run\', b\']: Will run job `\'),\\n        FixedWordlistDataModelElement(\'CronType\', [b\'cron.daily\', b\'cron.hourly\', b\'cron.monthly\', b\'cron.weekly\']),\\n        FixedDataModelElement(\'StartTime\', b\'\\\\\' in 5 min.\')]\\n\\n    service_children_cron_job_execution = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'Space1\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Job\', b\']: Job `\'),\\n        FixedWordlistDataModelElement(\'CronType\', [b\'cron.daily\', b\'cron.hourly\', b\'cron.monthly\', b\'cron.weekly\']),\\n        FixedDataModelElement(\'Started\', b\'\\\\\' started\')]\\n\\n    parsing_model = FirstMatchModelElement(\'model\', [\\n        SequenceModelElement(\'CronAnnouncement\', service_children_cron_job_announcement),\\n        SequenceModelElement(\'CronExecution\', service_children_cron_job_execution),\\n        SequenceModelElement(\'DailyCron\', service_children_cron_job), SequenceModelElement(\'DiskReport\', service_children_disk_report),\\n        SequenceModelElement(\'LoginDetails\', service_children_login_details), DecimalIntegerValueModelElement(\'Random\'),\\n        SequenceModelElement(\'RandomTime\', service_children_random_time), SequenceModelElement(\'Sensors\', service_children_sensors),\\n        SequenceModelElement(\'IPAddresses\', service_children_user_ip_address)])\\n\\n    # Some generic imports.\\n    from aminer.analysis import AtomFilters\\n\\n    # Create all global handler lists here and append the real handlers later on.\\n    # Use this filter to distribute all atoms to the analysis handlers.\\n    atom_filters = AtomFilters.SubhandlerFilter(None)\\n    analysis_context.register_component(atom_filters, component_name=\\"AtomFilter\\")\\n\\n    from aminer.analysis.TimestampCorrectionFilters import SimpleMonotonicTimestampAdjust\\n    simple_monotonic_timestamp_adjust = SimpleMonotonicTimestampAdjust([atom_filters])\\n    analysis_context.register_component(simple_monotonic_timestamp_adjust, component_name=\\"SimpleMonotonicTimestampAdjust\\")\\n\\n    from aminer.events.StreamPrinterEventHandler import StreamPrinterEventHandler\\n    import os\\n    import stat\\n    stpe = StreamPrinterEventHandler(analysis_context)\\n    aminer_rest_output = "/tmp/aminer-rest-output.log"\\n    mode = \'w+\'\\n    if os.path.exists(aminer_rest_output) and stat.S_ISFIFO(os.stat(aminer_rest_output).st_mode):\\n        mode = \'w\'\\n    stream = open(aminer_rest_output, mode)\\n    aminer_rest_stpe = StreamPrinterEventHandler(analysis_context, stream)\\n    from aminer.events.JsonConverterHandler import JsonConverterHandler\\n    aminer_rest_jch = JsonConverterHandler([aminer_rest_stpe], analysis_context, pretty_print=False)\\n\\n    from aminer.events.Utils import VolatileLogarithmicBackoffEventHistory\\n    volatile_logarithmic_backoff_event_history = VolatileLogarithmicBackoffEventHistory(100)\\n    anomaly_event_handlers = [stpe, aminer_rest_jch, volatile_logarithmic_backoff_event_history]\\n    analysis_context.register_component(volatile_logarithmic_backoff_event_history, component_name=\\"VolatileLogarithmicBackoffEventHistory\\")\\n\\n    # Now define the AtomizerFactory using the model. A simple line based one is usually sufficient.\\n    from aminer.input.SimpleByteStreamLineAtomizerFactory import SimpleByteStreamLineAtomizerFactory\\n    analysis_context.atomizer_factory = SimpleByteStreamLineAtomizerFactory(\\n        parsing_model, [simple_monotonic_timestamp_adjust], anomaly_event_handlers, use_real_time=True)\\n\\n    # Just report all unparsed atoms to the event handlers.\\n    from aminer.analysis.UnparsedAtomHandlers import SimpleUnparsedAtomHandler\\n    simple_unparsed_atom_handler = SimpleUnparsedAtomHandler(anomaly_event_handlers)\\n    atom_filters.add_handler(simple_unparsed_atom_handler, stop_when_handled_flag=True)\\n    analysis_context.register_component(simple_unparsed_atom_handler, component_name=\\"UnparsedHandler\\")\\n\\n    from aminer.analysis.TimestampsUnsortedDetector import TimestampsUnsortedDetector\\n    timestamps_unsorted_detector = TimestampsUnsortedDetector(analysis_context.aminer_config, anomaly_event_handlers)\\n    atom_filters.add_handler(timestamps_unsorted_detector)\\n    analysis_context.register_component(timestamps_unsorted_detector, component_name=\\"TimestampsUnsortedDetector\\")\\n\\n    from aminer.analysis import Rules\\n    from aminer.analysis.AllowlistViolationDetector import AllowlistViolationDetector\\n    allowlist_rules = [\\n        Rules.OrMatchRule([\\n            Rules.AndMatchRule([\\n                Rules.PathExistsMatchRule(\'/model/LoginDetails/PastTime/Time/Minutes\'),\\n                Rules.NegationMatchRule(Rules.ValueMatchRule(\'/model/LoginDetails/Username\', b\'root\'))]),\\n            Rules.AndMatchRule([\\n                Rules.NegationMatchRule(Rules.PathExistsMatchRule(\'/model/LoginDetails/PastTime/Time/Minutes\')),\\n                Rules.PathExistsMatchRule(\'/model/LoginDetails\')]),\\n            Rules.NegationMatchRule(Rules.PathExistsMatchRule(\'/model/LoginDetails\'))])]\\n\\n    # This rule list should trigger, when the line does not look like: User root (logged in, logged out)\\n    # or User \'username\' (logged in, logged out) x minutes ago.\\n    allowlist_violation_detector = AllowlistViolationDetector(analysis_context.aminer_config, allowlist_rules, anomaly_event_handlers)\\n    analysis_context.register_component(allowlist_violation_detector, component_name=\\"Allowlist\\")\\n    atom_filters.add_handler(allowlist_violation_detector)\\n\\n    from aminer.analysis.ParserCount import ParserCount\\n    parser_count = ParserCount(analysis_context.aminer_config, None, anomaly_event_handlers, 10)\\n    analysis_context.register_component(parser_count, component_name=\\"ParserCount\\")\\n    atom_filters.add_handler(parser_count)\\n\\n    from aminer.analysis.EventCorrelationDetector import EventCorrelationDetector\\n    ecd = EventCorrelationDetector(analysis_context.aminer_config, anomaly_event_handlers, check_rules_flag=True,\\n                                   hypothesis_max_delta_time=1.0, learn_mode=True)\\n    analysis_context.register_component(ecd, component_name=\\"EventCorrelationDetector\\")\\n    atom_filters.add_handler(ecd)\\n\\n    from aminer.analysis.NewMatchPathDetector import NewMatchPathDetector\\n    new_match_path_detector = NewMatchPathDetector(analysis_context.aminer_config, anomaly_event_handlers, learn_mode=True)\\n    analysis_context.register_component(new_match_path_detector, component_name=\\"NewMatchPath\\")\\n    atom_filters.add_handler(new_match_path_detector)\\n\\n    def tuple_transformation_function(match_value_list):\\n        \\"\\"\\"Only allow output of the EnhancedNewMatchPathValueComboDetector\\n        after every 10000th element.\\"\\"\\"\\n        extra_data = enhanced_new_match_path_value_combo_detector.known_values_dict.get(tuple(match_value_list))\\n        if extra_data is not None:\\n            mod = 10000\\n            if (extra_data[2] + 1) % mod == 0:\\n                enhanced_new_match_path_value_combo_detector.learn_mode = False\\n            else:\\n                enhanced_new_match_path_value_combo_detector.learn_mode = True\\n        return match_value_list\\n\\n    from aminer.analysis.EnhancedNewMatchPathValueComboDetector import EnhancedNewMatchPathValueComboDetector\\n    enhanced_new_match_path_value_combo_detector = EnhancedNewMatchPathValueComboDetector(\\n        analysis_context.aminer_config, [\'/model/DailyCron/UName\', \'/model/DailyCron/JobNumber\'], anomaly_event_handlers,\\n        learn_mode=False, tuple_transformation_function=tuple_transformation_function)\\n    analysis_context.register_component(enhanced_new_match_path_value_combo_detector, component_name=\\"EnhancedNewValueCombo\\")\\n    atom_filters.add_handler(enhanced_new_match_path_value_combo_detector)\\n\\n    from aminer.analysis.HistogramAnalysis import HistogramAnalysis, LinearNumericBinDefinition, ModuloTimeBinDefinition, \\\\\\n        PathDependentHistogramAnalysis\\n    modulo_time_bin_definition = ModuloTimeBinDefinition(86400, 3600, 0, 1, 24, True)\\n    linear_numeric_bin_definition = LinearNumericBinDefinition(50, 5, 20, True)\\n    histogram_analysis = HistogramAnalysis(analysis_context.aminer_config, [\\n        (\'/model/RandomTime/Random\', modulo_time_bin_definition), (\'/model/Random\', linear_numeric_bin_definition)], 10,\\n        anomaly_event_handlers)\\n    analysis_context.register_component(histogram_analysis, component_name=\\"HistogramAnalysis\\")\\n    atom_filters.add_handler(histogram_analysis)\\n\\n    path_dependent_histogram_analysis = PathDependentHistogramAnalysis(analysis_context.aminer_config, \'/model/RandomTime\',\\n                                                                       modulo_time_bin_definition, 10, anomaly_event_handlers)\\n    analysis_context.register_component(path_dependent_histogram_analysis, component_name=\\"PathDependentHistogramAnalysis\\")\\n    atom_filters.add_handler(path_dependent_histogram_analysis)\\n\\n    from aminer.analysis.MatchValueAverageChangeDetector import MatchValueAverageChangeDetector\\n    match_value_average_change_detector = MatchValueAverageChangeDetector(analysis_context.aminer_config, anomaly_event_handlers, None,\\n                                                                          [\'/model/Random\'], 100, 10)\\n    analysis_context.register_component(match_value_average_change_detector, component_name=\\"MatchValueAverageChange\\")\\n    atom_filters.add_handler(match_value_average_change_detector)\\n\\n    import sys\\n    from aminer.analysis.MatchValueStreamWriter import MatchValueStreamWriter\\n    match_value_stream_writer = MatchValueStreamWriter(\\n        sys.stdout, [\'/model/Sensors/CPUTemp\', \'/model/Sensors/CPUWorkload\', \'/model/Sensors/DTM\'], b\';\', b\'\')\\n    analysis_context.register_component(match_value_stream_writer, component_name=\\"MatchValueStreamWriter\\")\\n    atom_filters.add_handler(match_value_stream_writer)\\n\\n    from aminer.analysis.NewMatchPathValueComboDetector import NewMatchPathValueComboDetector\\n    new_match_path_value_combo_detector = NewMatchPathValueComboDetector(analysis_context.aminer_config, [\\n        \'/model/IPAddresses/Username\', \'/model/IPAddresses/IP\'], anomaly_event_handlers, learn_mode=False)\\n    analysis_context.register_component(new_match_path_value_combo_detector, component_name=\\"NewMatchPathValueCombo\\")\\n    atom_filters.add_handler(new_match_path_value_combo_detector)\\n\\n    from aminer.analysis.NewMatchIdValueComboDetector import NewMatchIdValueComboDetector\\n    new_match_id_value_combo_detector = NewMatchIdValueComboDetector(\\n        analysis_context.aminer_config, [\'/model/type/path/id\', \'/model/type/syscall/id\'], anomaly_event_handlers,\\n        id_path_list=[\'/model/type/path/id\', \'/model/type/syscall/id\'], min_allowed_time_diff=5, learn_mode=True,\\n        allow_missing_values_flag=True, output_logline=True)\\n    analysis_context.register_component(new_match_id_value_combo_detector, component_name=\\"NewMatchIdValueComboDetector\\")\\n    atom_filters.add_handler(new_match_id_value_combo_detector)\\n\\n    from aminer.analysis.NewMatchPathValueDetector import NewMatchPathValueDetector\\n    new_match_path_value_detector = NewMatchPathValueDetector(analysis_context.aminer_config, [\\n        \'/model/DailyCron/Job Number\', \'/model/IPAddresses/Username\'], anomaly_event_handlers, learn_mode=False)\\n    analysis_context.register_component(new_match_path_value_detector, component_name=\\"NewMatchPathValue\\")\\n    atom_filters.add_handler(new_match_path_value_detector)\\n\\n    from aminer.analysis.MissingMatchPathValueDetector import MissingMatchPathValueDetector\\n    missing_match_path_value_detector = MissingMatchPathValueDetector(\\n        analysis_context.aminer_config, [\'/model/DiskReport/Space\'], anomaly_event_handlers, learn_mode=False, default_interval=2,\\n        realert_interval=5)\\n    analysis_context.register_component(missing_match_path_value_detector, component_name=\\"MissingMatch\\")\\n    atom_filters.add_handler(missing_match_path_value_detector)\\n\\n    from aminer.analysis.TimeCorrelationDetector import TimeCorrelationDetector\\n    time_correlation_detector = TimeCorrelationDetector(\\n        analysis_context.aminer_config, anomaly_event_handlers, 2, min_rule_attributes=1, max_rule_attributes=5,\\n        record_count_before_event=70000, output_logline=True)\\n    analysis_context.register_component(time_correlation_detector, component_name=\\"TimeCorrelationDetector\\")\\n    atom_filters.add_handler(time_correlation_detector)\\n\\n    from aminer.analysis.TimeCorrelationViolationDetector import TimeCorrelationViolationDetector, CorrelationRule, EventClassSelector\\n    cron_job_announcement = CorrelationRule(\'CronJobAnnouncement\', 5, 6, artefact_match_parameters=[\\n        (\'/model/CronAnnouncement/JobNumber\', \'/model/CronExecution/JobNumber\')])\\n    a_class_selector = EventClassSelector(\'Announcement\', [cron_job_announcement], None)\\n    b_class_selector = EventClassSelector(\'Execution\', None, [cron_job_announcement])\\n    rules = [Rules.PathExistsMatchRule(\'/model/CronAnnouncement/Run\', a_class_selector),\\n             Rules.PathExistsMatchRule(\'/model/CronExecution/Job\', b_class_selector)]\\n\\n    time_correlation_violation_detector = TimeCorrelationViolationDetector(analysis_context.aminer_config, rules, anomaly_event_handlers)\\n    analysis_context.register_component(time_correlation_violation_detector, component_name=\\"TimeCorrelationViolationDetector\\")\\n    atom_filters.add_handler(time_correlation_violation_detector)\\n\\n    from aminer.events.DefaultMailNotificationEventHandler import DefaultMailNotificationEventHandler\\n    if DefaultMailNotificationEventHandler.CONFIG_KEY_MAIL_TARGET_ADDRESS in analysis_context.aminer_config.config_properties:\\n        mail_notification_handler = DefaultMailNotificationEventHandler(analysis_context)\\n        analysis_context.register_component(mail_notification_handler, component_name=\\"MailHandler\\")\\n        anomaly_event_handlers.append(mail_notification_handler)\\n\\n    setattr(analysis_context.get_component_by_name(\\"NewMatchPathValueCombo\\"), \\"learn_mode\\", False)\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600\'"'
        contentyml = b'"Remote execution response: \'LearnMode: False\\n\\nCore.LogDir: \'/tmp/lib/aminer/log\'\\n\\nCore.PersistenceDir: \'/tmp/lib/aminer\'\\n\\nCore.PersistencePeriod: 600\\n\\n# can not use unix socket for aminer-rest, because the socket needs to be open, while aminer-rest needs aminer running at startup.\\nLogResourceList:\\n        - \'file:///tmp/syslog\'\\n        - \'file:///tmp/aminer-rest-input.log\'\\n\\nRemoteControlSocket: \'/var/run/aminer-remote.socket\'\\n\\nMailAlerting.TargetAddress: \'root@localhost\'\\n\\nMailAlerting.FromAddress: \'root@localhost\'\\n\\nMailAlerting.SubjectPrefix: \'aminer Alerts:\'\\n\\nMailAlerting.AlertGraceTime: 0\\n\\nMailAlerting.EventCollectTime: 0\\n\\nMailAlerting.MinAlertGap: 0\\n\\nMailAlerting.MaxAlertGap: 600\\n\\nMailAlerting.MaxEventsPerMessage: 1000\\n\\nLogPrefix: \'Original log line: \'\\n\\nAminerId: \'demo-aminer\'\\n\\nParser:\\n       - id: space\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \' Current Disk Data is: Filesystem     Type  Size  Used Avail Use%\'\\n\\n       - id: data\\n         type: DelimitedDataModelElement\\n         name: \'Data\'\\n         delimiter: \'%\'\'/\'\\n\\n       - id: rest\\n         type: AnyByteDataModelElement\\n         name: \'Rest\'\\n\\n       - id: userLoginDetails\\n         type: FixedDataModelElement\\n         name: \'User\'\\n         args: \'User \'\\n\\n       - id: userIpAddress\\n         type: FixedDataModelElement\\n         name: \'User\'\\n         args: \'User \'\\n\\n       - id: username\\n         type: DelimitedDataModelElement\\n         name: \'Username\'\\n         delimiter: \' \'\\n\\n       - id: status\\n         type: FixedWordlistDataModelElement\\n         name: \'Status\'\\n         args:\\n           - \' logged in\'\\n           - \' logged out\'\\n\\n       - id: blank\\n         type: FixedDataModelElement\\n         name: \'Blank\'\\n         args: \' \'\\n\\n       - id: minutes\\n         type: DecimalIntegerValueModelElement\\n         name: \'Minutes\'\\n\\n       - id: ago\\n         type: FixedDataModelElement\\n         name: \'Ago\'\\n         args: \' minutes ago.\'\\n\\n       - id: time\\n         type: SequenceModelElement\\n         name: \'Time\'\\n         args:\\n           - blank\\n           - minutes\\n           - ago\\n\\n       - id: pastTime\\n         type: OptionalMatchModelElement\\n         name: \'PastTime\'\\n         args: time\\n\\n       - id: dtm\\n         type: DateTimeModelElement\\n         name: \'DTM\'\\n         date_format: \'%Y-%m-%d %H:%M:%S\'\\n         start_year: null\\n         text_locale: null\\n         max_time_jump_seconds: 86400\\n\\n       - id: uNameSpace1\\n         type: FixedDataModelElement\\n         name: \'UNameSpace1\'\\n         args: \' \'\\n\\n       - id: uName\\n         type: DelimitedDataModelElement\\n         name: \'UName\'\\n         delimiter: \' \'\\n\\n       - id: uNameSpace2\\n         type: FixedDataModelElement\\n         name: \'UNameSpace2\'\\n         args: \' \'\\n\\n       - id: delimitedUser\\n         type: DelimitedDataModelElement\\n         name: \'User\'\\n         delimiter: \' \'\\n\\n       - id: cron\\n         type: FixedDataModelElement\\n         name: \'Cron\'\\n         args: \' cron[\'\\n\\n       - id: jobNumber\\n         type: DecimalIntegerValueModelElement\\n         name: \'JobNumber\'\\n\\n       - id: details\\n         type: FixedDataModelElement\\n         name: \'Details\'\\n         args: \']: Job `cron.daily` started.\'\\n\\n       - id: spaceRandom\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \'Random: \'\\n\\n       - id: random\\n         type: DecimalIntegerValueModelElement\\n         name: \'Random\'\\n\\n       - id: fixedTemp\\n         type: FixedDataModelElement\\n         name: \'FixedTemp\'\\n         args: \'CPU Temp: \'\\n\\n       - id: temp\\n         type: DecimalIntegerValueModelElement\\n         name: \'Temp\'\\n\\n       - id: degrees\\n         type: FixedDataModelElement\\n         name: \'Degrees\'\\n         args: \'\xc2\xb0C\'\\n\\n       - id: cpuTemp\\n         type: SequenceModelElement\\n         name: \'CPUTemp\'\\n         args:\\n           - fixedTemp\\n           - temp\\n           - degrees\\n\\n       - id: space1\\n         type: FixedDataModelElement\\n         name: \'Space1\'\\n         args: \', \'\\n\\n       - id: fixedWorkload\\n         type: FixedDataModelElement\\n         name: \'FixedWorkload\'\\n         args: \'CPU Workload: \'\\n\\n       - id: workload\\n         type: DecimalIntegerValueModelElement\\n         name: \'Workload\'\\n\\n       - id: percent\\n         type: FixedDataModelElement\\n         name: \'Percent\'\\n         args: \'%\'\\n\\n       - id: cpuWorkload\\n         type: SequenceModelElement\\n         name: \'CPUWorkload\'\\n         args:\\n           - fixedWorkload\\n           - workload\\n           - percent\\n\\n       - id: space2\\n         type: FixedDataModelElement\\n         name: \'Space2\'\\n         args: \', \'\\n\\n       - id: action\\n         type: FixedDataModelElement\\n         name: \'Action\'\\n         args: \' changed IP address to \'\\n\\n       - id: ip\\n         type: IpAddressDataModelElement\\n         name: \'IP\'\\n\\n       - id: fixedSpace\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \' \'\\n\\n       - id: run\\n         type: FixedDataModelElement\\n         name: \'Run\'\\n         args: \']: Will run job `\'\\n\\n       - id: cronType\\n         type: FixedWordlistDataModelElement\\n         name: \'CronType\'\\n         args:\\n           - \'cron.daily\'\\n           - \'cron.hourly\'\\n           - \'cron.monthly\'\\n           - \'cron.weekly\'\\n\\n       - id: startTime\\n         type: FixedDataModelElement\\n         name: \'StartTime\'\\n         args: \\"\' in 5 min.\\"\\n\\n       - id: emptySpace1\\n         type: FixedDataModelElement\\n         name: \'Space1\'\\n         args: \' \'\\n\\n       - id: job\\n         type: FixedDataModelElement\\n         name: \'Job\'\\n         args: \']: Job `\'\\n\\n       - id: started\\n         type: FixedDataModelElement\\n         name: \'Started\'\\n         args: \\"\' started\\"\\n\\n       - id: cronAnnouncement\\n         type: SequenceModelElement\\n         name: \'CronAnnouncement\'\\n         args:\\n           - dtm\\n           - fixedSpace\\n           - uName\\n           - cron\\n           - jobNumber\\n           - run\\n           - cronType\\n           - startTime\\n\\n       - id: cronExecution\\n         type: SequenceModelElement\\n         name: \'CronExecution\'\\n         args:\\n           - dtm\\n           - emptySpace1\\n           - uName\\n           - cron\\n           - jobNumber\\n           - job\\n           - cronType\\n           - started\\n\\n       - id: dailyCron\\n         type: SequenceModelElement\\n         name: \'DailyCron\'\\n         args:\\n           - dtm\\n           - uNameSpace1\\n           - uName\\n           - uNameSpace2\\n           - delimitedUser\\n           - cron\\n           - jobNumber\\n           - details\\n\\n       - id: diskReport\\n         type: SequenceModelElement\\n         name: \'DiskReport\'\\n         args:\\n           - space\\n           - data\\n           - rest\\n\\n       - id: loginDetails\\n         type: SequenceModelElement\\n         name: \'LoginDetails\'\\n         args:\\n           - userLoginDetails\\n           - username\\n           - status\\n           - pastTime\\n\\n       - id: randomTime\\n         type: SequenceModelElement\\n         name: \'RandomTime\'\\n         args:\\n           - spaceRandom\\n           - random\\n\\n       - id: sensors\\n         type: SequenceModelElement\\n         name: \'Sensors\'\\n         args:\\n           - cpuTemp\\n           - space1\\n           - cpuWorkload\\n           - space2\\n           - dtm\\n\\n       - id: ipAddresses\\n         type: SequenceModelElement\\n         name: \'IPAddresses\'\\n         args:\\n           - userIpAddress\\n           - username\\n           - action\\n           - ip\\n\\n       - id: model\\n         start: True\\n         type: FirstMatchModelElement\\n         name: \'model\'\\n         args:\\n           - cronAnnouncement\\n           - cronExecution\\n           - dailyCron\\n           - diskReport\\n           - loginDetails\\n           - random\\n           - randomTime\\n           - sensors\\n           - ipAddresses\\n\\nInput:\\n        timestamp_paths: [\\"/model/DailyCron/DTM\\"]\\n        adjust_timestamps: True\\n        use_real_time: True\\n\\nAnalysis:\\n        - type: TimestampsUnsortedDetector\\n          id: TimestampsUnsortedDetector\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule1\\n          path: \\"/model/LoginDetails/PastTime/Time/Minutes\\"\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule2\\n          path: \\"/model/LoginDetails\\"\\n        - type: ValueMatchRule\\n          id: value_match_rule\\n          path: \\"/model/LoginDetails/Username\\"\\n          value: \\"root\\"\\n        - type: NegationMatchRule\\n          id: negation_match_rule1\\n          sub_rule: \\"value_match_rule\\"\\n        - type: NegationMatchRule\\n          id: negation_match_rule2\\n          sub_rule: \\"path_exists_match_rule2\\"\\n        - type: AndMatchRule\\n          id: and_match_rule1\\n          sub_rules:\\n            - \\"path_exists_match_rule1\\"\\n            - \\"negation_match_rule1\\"\\n        - type: AndMatchRule\\n          id: and_match_rule2\\n          sub_rules:\\n            - \\"negation_match_rule1\\"\\n            - \\"path_exists_match_rule2\\"\\n        - type: OrMatchRule\\n          id: or_match_rule\\n          sub_rules:\\n            - \\"and_match_rule1\\"\\n            - \\"and_match_rule2\\"\\n            - \\"negation_match_rule2\\"\\n        - type: AllowlistViolationDetector\\n          id: Allowlist\\n          allowlist_rules:\\n            - \\"or_match_rule\\"\\n        - type: ParserCount\\n          id: ParserCount\\n          report_interval: 10\\n        - type: MatchFilter\\n          id: MatchFilter\\n          paths:\\n            - \\"/model/Random\\"\\n          value_list:\\n            - 1\\n            - 10\\n            - 100\\n        - type: EnhancedNewMatchPathValueComboDetector\\n          id: EnhancedNewValueCombo\\n          paths:\\n            - \\"/model/DailyCron/UName\\"\\n            - \\"/model/DailyCron/JobNumber\\"\\n          tuple_transformation_function: \\"demo\\"\\n          learn_mode: True\\n        - type: ModuloTimeMatchRule\\n          id: \\"mt\\"\\n          path: \\"mtmr\\"\\n          seconds_modulo: 3\\n          lower_limit: 0\\n          upper_limit: 3\\n        - type: ValueDependentModuloTimeMatchRule\\n          id: \\"vdmt\\"\\n          path: \\"vdmtmr\\"\\n          seconds_modulo: 3\\n          paths:\\n            - \\"/model/ECD/g\\"\\n            - \\"/model/ECD/h\\"\\n            - \\"/model/ECD/i\\"\\n            - \\"/model/ECD/j\\"\\n            - \\"/model/ECD/k\\"\\n            - \\"/model/ECD/l\\"\\n          limit_lookup_dict:\\n            e:\\n              - 0\\n              - 2.95\\n          default_limit:\\n            - 0\\n            - 3\\n        - type: ValueDependentDelegatedMatchRule\\n          id: \\"value_dependent_delegated_match_rule\\"\\n          paths:\\n            - \\"/model/ECD/g\\"\\n            - \\"/model/ECD/h\\"\\n            - \\"/model/ECD/i\\"\\n            - \\"/model/ECD/j\\"\\n            - \\"/model/ECD/k\\"\\n            - \\"/model/ECD/l\\"\\n          rule_lookup_dict:\\n            (b\\"g\\",): \\"mt\\"\\n            (b\\"h\\",): \\"mt\\"\\n            (b\\"i\\",): \\"mt\\"\\n            (b\\"j\\",): \\"vdmt\\"\\n            (b\\"k\\",): \\"vdmt\\"\\n            (b\\"l\\",): \\"vdmt\\"\\n          default_rule: \\"mt\\"\\n        - type: EventGenerationMatchAction\\n          id: \\"ip_match_action\\"\\n          event_type: \\"Analysis.Rules.IPv4InRFC1918MatchRule\\"\\n          event_message: \\"Private IP address occurred!\\"\\n        - type: IPv4InRFC1918MatchRule\\n          id: \\"ipv4_in_rfc1918_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          match_action: \\"ip_match_action\\"\\n        - type: DebugHistoryMatchRule\\n          id: \\"debug_history_match_rule\\"\\n          debug_mode: True\\n        - type: ValueListMatchRule\\n          id: \\"value_list_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          value_list:\\n            - 134744072\\n            - 134743044\\n        - type: NegationMatchRule\\n          id: \\"negation_list\\"\\n          sub_rule: \\"value_list_match_rule\\"\\n        - type: ValueRangeMatchRule\\n          id: \\"value_range_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          lower_limit: 167772160\\n          upper_limit: 184549375\\n        - type: NegationMatchRule\\n          id: \\"negation_range\\"\\n          sub_rule: \\"value_range_match_rule\\"\\n        - type: StringRegexMatchRule\\n          id: \\"string_regex_match_rule\\"\\n          path: \\"/model/type/syscall/success\\"\\n          regex: \\"^no$\\"\\n        - type: NegationMatchRule\\n          id: \\"negation_string_regex\\"\\n          sub_rule: \\"string_regex_match_rule\\"\\n        - type: ParallelMatchRule\\n          id: \\"parallel_match_rule\\"\\n          sub_rules:\\n            - \\"value_dependent_delegated_match_rule\\"\\n            - \\"ipv4_in_rfc1918_match_rule\\"\\n            - \\"debug_history_match_rule\\"\\n        - type: AndMatchRule\\n          id: \\"time_and_match_rule\\"\\n          sub_rules:\\n            - \\"parallel_match_rule\\"\\n            - \\"negation_list\\"\\n            - \\"negation_range\\"\\n            - \\"negation_string_regex\\"\\n        - type: AllowlistViolationDetector\\n          id: TimeAllowlist\\n          allowlist_rules:\\n            - \\"time_and_match_rule\\"\\n        - type: LinearNumericBinDefinition\\n          id: linear_numeric_bin_definition\\n          lower_limit: 50\\n          bin_size: 5\\n          bin_count: 20\\n          outlier_bins_flag: True\\n        - type: ModuloTimeBinDefinition\\n          id: modulo_time_bin_definition\\n          modulo_value: 86400\\n          time_unit: 3600\\n          lower_limit: 0\\n          bin_size: 1\\n          bin_count: 24\\n          outlier_bins_flag: True\\n        - type: HistogramAnalysis\\n          id: HistogramAnalysis\\n          histogram_defs: [[\\"/model/RandomTime/Random\\", \\"linear_numeric_bin_definition\\"]]\\n          report_interval: 10\\n        - type: PathDependentHistogramAnalysis\\n          id: PathDependentHistogramAnalysis\\n          path: \\"/model/RandomTime\\"\\n          bin_definition: \\"modulo_time_bin_definition\\"\\n          report_interval: 10\\n        - type: MatchValueAverageChangeDetector\\n          id: MatchValueAverageChange\\n          timestamp_path: null\\n          paths:\\n            - \\"/model/Random\\"\\n          min_bin_elements: 100\\n          min_bin_time: 10\\n        - type: MatchValueStreamWriter\\n          id: MatchValueStreamWriter\\n          stream: \\"sys.stdout\\"\\n          paths:\\n            - \\"/model/Sensors/CPUTemp\\"\\n            - \\"/model/Sensors/CPUWorkload\\"\\n            - \\"/model/Sensors/DTM\\"\\n          separator: \\";\\"\\n          missing_value_string: \\"\\"\\n        - type: NewMatchPathValueComboDetector\\n          id: NewMatchPathValueCombo\\n          paths:\\n            - \\"/model/IPAddresses/Username\\"\\n            - \\"/model/IPAddresses/IP\\"\\n          learn_mode: False\\n          log_resource_ignore_list:\\n            - \'file:///tmp/other_syslog\'\\n        - type: NewMatchIdValueComboDetector\\n          id: NewMatchIdValueComboDetector\\n          paths:\\n            - \\"/model/type/path/name\\"\\n            - \\"/model/type/syscall/syscall\\"\\n          id_path_list:\\n            - \\"/model/type/path/id\\"\\n            - \\"/model/type/syscall/id\\"\\n          min_allowed_time_diff: 5\\n          allow_missing_values: True\\n          learn_mode: True\\n        - type: NewMatchPathValueDetector\\n          id: NewMatchPathValue\\n          paths:\\n            - \\"/model/DailyCron/JobNumber\\"\\n            - \\"/model/IPAddresses/Username\\"\\n          learn_mode: True\\n        - type: MissingMatchPathValueDetector\\n          id: MissingMatch\\n          paths:\\n            - \\"/model/DiskReport/Space\\"\\n          check_interval: 2\\n          realert_interval: 5\\n          learn_mode: True\\n        - type: TimeCorrelationDetector\\n          id: TimeCorrelationDetector\\n          parallel_check_count: 2\\n          min_rule_attributes: 1\\n          max_rule_attributes: 5\\n          record_count_before_event: 10000\\n        - type: CorrelationRule\\n          rule_id: correlation_rule\\n          min_time_delta: 5\\n          max_time_delta: 6\\n          artefact_match_parameters: [[\\"/model/CronAnnouncement/JobNumber\\", \\"/model/CronExecution/JobNumber\\"]]\\n        - type: EventClassSelector\\n          action_id: a_class_selector\\n          artefact_a_rules:\\n            - correlation_rule\\n        - type: EventClassSelector\\n          action_id: b_class_selector\\n          artefact_b_rules:\\n            - correlation_rule\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule3\\n          path: \\"/model/CronAnnouncement/Run\\"\\n          match_action: a_class_selector\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule4\\n          path: \\"/model/CronExecution/Job\\"\\n          match_action: b_class_selector\\n        - type: TimeCorrelationViolationDetector\\n          id: TimeCorrelationViolationDetector\\n          ruleset:\\n            - path_exists_match_rule3\\n            - path_exists_match_rule4\\n\\nEventHandlers:\\n        - id: stpe\\n          type: StreamPrinterEventHandler\\n\\n        - id: aminer-rest-stpe\\n          type: StreamPrinterEventHandler\\n          json: True\\n          output_file_path: /tmp/aminer-rest-output.log\\n\'"'

        old_component_name = "NewMatchPathValueCombo"
        new_component_name = "NewMatchPathValueComboDetector"
        response = self.client.put(ANALYSIS_COMPONENT_PATH + "?old_component_name=%s&new_component_name=%s" % (
            old_component_name, new_component_name), headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f"{{\"message\":\"Successfully renamed analysis component from {old_component_name} to {new_component_name}\"}}".encode())
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        c = contentpy.replace(b'\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600\'"', f"\n    component = analysis_context.get_component_by_name(\"{old_component_name}\")\n    analysis_context.registered_components_by_name[\"{old_component_name}\"] = None\n    analysis_context.registered_components_by_name[\"{new_component_name}\"] = component\nconfig_properties[\\\"Core.PersistencePeriod\\\"] = 600".encode() + b'\'"')
        if self.dest_config_file.endswith(".yml"):
            c = contentyml.replace(b'- type: NewMatchPathValueComboDetector\\n          id: NewMatchPathValueCombo\\n          paths:\\n            - \\"/model/IPAddresses/Username\\"\\n            - \\"/model/IPAddresses/IP\\"\\n          learn_mode: False', b'- type: NewMatchPathValueComboDetector\\n          id: NewMatchPathValueComboDetector\\n          paths:\\n            - \\"/model/IPAddresses/Username\\"\\n            - \\"/model/IPAddresses/IP\\"\\n          learn_mode: False')
        self.assertEqual(new_live_config, c.decode("unicode-escape"))

        # reset value
        self.client.put(ANALYSIS_COMPONENT_PATH + "?old_component_name=%s&new_component_name=%s" % (
            new_component_name, old_component_name), headers=self.authorization_headers)
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        c = contentpy.replace(b'\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600\'"', f"\n    component = analysis_context.get_component_by_name(\"{old_component_name}\")\n    analysis_context.registered_components_by_name[\"{old_component_name}\"] = None\n    analysis_context.registered_components_by_name[\"{new_component_name}\"] = component\n    component = analysis_context.get_component_by_name(\"{new_component_name}\")\n    analysis_context.registered_components_by_name[\"{new_component_name}\"] = None\n    analysis_context.registered_components_by_name[\"{old_component_name}\"] = component\nconfig_properties[\\\"Core.PersistencePeriod\\\"] = 600".encode() + b'\'"')
        if self.dest_config_file.endswith(".yml"):
            c = contentyml
        self.assertEqual(new_live_config, c.decode("unicode-escape"))

        response = self.client.put(ANALYSIS_COMPONENT_PATH + "?old_component_name=%s&new_component_name=%s" % (
            old_component_name, new_component_name))
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")

        response = self.client.put(ANALYSIS_COMPONENT_PATH + "?old_component_name=%s&new_component_name=%s" % (
            old_component_name, new_component_name), headers={
            "Authorization": "%s %s" % (self.token_type, self.access_token + "failedtoken")})
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")

        old_component_name = "NotExistingComponent"
        response = self.client.put(ANALYSIS_COMPONENT_PATH + "?old_component_name=%s&new_component_name=%s" % (
            old_component_name, new_component_name), headers=self.authorization_headers)
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f'{{"detail":"the component \'{old_component_name}\' does not exist."}}'.encode())

        old_component_name = "NewMatchPathValueCombo"
        response = self.client.put(
            ANALYSIS_COMPONENT_PATH + "?old_component_name=%s&new_component_name=%s" % (old_component_name, new_component_name),
            headers={"content-md5": "md5 string", **self.authorization_headers})
        self.assertEqual(response.status_code, 501)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f'{{"detail":"{ERR_HEADER_NOT_IMPLEMENTED % "content-md5"}"}}'.encode())

    def test7add_handler_to_atom_filter_and_register_analysis_component(self):
        """This test is problematic as there is no way to remove analysis
        components without restarting the AMiner."""
        contentpy = b'"Remote execution response: \'from aminer.parsing.FirstMatchModelElement import FirstMatchModelElement\\nfrom aminer.parsing.SequenceModelElement import SequenceModelElement\\nfrom aminer.parsing.FixedDataModelElement import FixedDataModelElement\\nfrom aminer.parsing.DelimitedDataModelElement import DelimitedDataModelElement\\nfrom aminer.parsing.AnyByteDataModelElement import AnyByteDataModelElement\\nfrom aminer.parsing.FixedWordlistDataModelElement import FixedWordlistDataModelElement\\nfrom aminer.parsing.DecimalIntegerValueModelElement import DecimalIntegerValueModelElement\\nfrom aminer.parsing.DateTimeModelElement import DateTimeModelElement\\nfrom aminer.parsing.IpAddressDataModelElement import IpAddressDataModelElement\\nfrom aminer.parsing.OptionalMatchModelElement import OptionalMatchModelElement\\n\\n# This is a template for the \\"aminer\\" logfile miner tool. Copy\\n# it to \\"config.py\\" and define your ruleset.\\n\\nconfig_properties = {}\\n\\n# Define the list of log resources to read from: the resources\\n# named here do not need to exist when aminer is started. This\\n# will just result in a warning. However, if they exist, they have\\n# to be readable by the aminer process! Supported types are:\\n# * file://[path]: Read data from file, reopen it after rollover\\n# * unix://[path]: Open the path as UNIX local socket for reading\\n\\n# can not use unix socket for aminer-rest, because the socket needs to be open, while aminer-rest needs aminer running at startup.\\nconfig_properties[\'LogResourceList\'] = [\'file:///tmp/syslog\', \'file:///tmp/aminer-rest-input.log\']\\n\\n# Define the uid/gid of the process that runs the calculation\\n# after opening the log files:\\nconfig_properties[\'AminerUser\'] = \'aminer\'\\nconfig_properties[\'AminerGroup\'] = \'aminer\'\\n\\n# Define the path, where aminer will listen for incoming remote\\n# control connections. When missing, no remote control socket\\n# will be created.\\nconfig_properties[\'RemoteControlSocket\'] = \'/var/run/aminer-remote.socket\'\\n\\n# Read the analyis from this file. That part of configuration\\n# is separated from the main configuration so that it can be loaded\\n# only within the analysis child. Non-absolute path names are\\n# interpreted relatively to the main configuration file (this\\n# file). When empty, this configuration has to contain the configuration\\n# for the child also.\\n# config_properties[\'AnalysisConfigFile\'] = \'analysis.py\'\\n\\nconfig_properties[\'Core.LogDir\'] = \'/tmp/lib/aminer/log\'\\n# Read and store information to be used between multiple invocations\\n# of aminer in this directory. The directory must only be accessible\\n# to the \'AminerUser\' but not group/world readable. On violation,\\n# aminer will refuse to start. When undefined, \'/var/lib/aminer\'\\n# is used.\\nconfig_properties[\'Core.PersistenceDir\'] = \'/tmp/lib/aminer\'\\n\\n# Define a target e-mail address to send alerts to. When undefined,\\n# no e-mail notification hooks are added.\\nconfig_properties[\'MailAlerting.TargetAddress\'] = \'root@localhost\'\\n# Sender address of e-mail alerts. When undefined, \\"sendmail\\"\\n# implementation on host will decide, which sender address should\\n# be used.\\nconfig_properties[\'MailAlerting.FromAddress\'] = \'root@localhost\'\\n# Define, which text should be prepended to the standard aminer\\n# subject. Defaults to \\"aminer Alerts:\\"\\nconfig_properties[\'MailAlerting.SubjectPrefix\'] = \'aminer Alerts:\'\\n# Define a grace time after startup before aminer will react to\\n# an event and send the first alert e-mail. Defaults to 0 (any\\n# event can immediately trigger alerting).\\nconfig_properties[\'MailAlerting.AlertGraceTime\'] = 0\\n# Define how many seconds to wait after a first event triggered\\n# the alerting procedure before really sending out the e-mail.\\n# In that timespan, events are collected and will be sent all\\n# using a single e-mail. Defaults to 10 seconds.\\nconfig_properties[\'MailAlerting.EventCollectTime\'] = 0\\n# Define the minimum time between two alert e-mails in seconds\\n# to avoid spamming. All events during this timespan are collected\\n# and sent out with the next report. Defaults to 600 seconds.\\nconfig_properties[\'MailAlerting.MinAlertGap\'] = 0\\n# Define the maximum time between two alert e-mails in seconds.\\n# When undefined this defaults to \\"MailAlerting.MinAlertGap\\".\\n# Otherwise this will activate an exponential backoff to reduce\\n# messages during permanent error states by increasing the alert\\n# gap by 50% when more alert-worthy events were recorded while\\n# the previous gap time was not yet elapsed.\\nconfig_properties[\'MailAlerting.MaxAlertGap\'] = 600\\n# Define how many events should be included in one alert mail\\n# at most. This defaults to 1000\\nconfig_properties[\'MailAlerting.MaxEventsPerMessage\'] = 1000\\nconfig_properties[\'LogPrefix\'] = \'Original log line: \'\\n\\n# Add your ruleset here:\\n\\n\\ndef build_analysis_pipeline(analysis_context):\\n    \\"\\"\\"Define the function to create pipeline for parsing the log data.\\n\\n    It has also to define an AtomizerFactory to instruct aminer how to\\n    process incoming data streams to create log atoms from them.\\n    \\"\\"\\"\\n    # Build the parsing model:\\n\\n    service_children_disk_report = [\\n        FixedDataModelElement(\'Space\', b\' Current Disk Data is: Filesystem     Type  Size  Used Avail Use%\'),\\n        DelimitedDataModelElement(\'Data\', b\'%\'), AnyByteDataModelElement(\'Rest\')]\\n\\n    service_children_login_details = [\\n        FixedDataModelElement(\'User\', b\'User \'), DelimitedDataModelElement(\'Username\', b\' \'),\\n        FixedWordlistDataModelElement(\'Status\', [b\' logged in\', b\' logged out\']),\\n        OptionalMatchModelElement(\'PastTime\', SequenceModelElement(\'Time\', [\\n            FixedDataModelElement(\'Blank\', b\' \'), DecimalIntegerValueModelElement(\'Minutes\'),\\n            FixedDataModelElement(\'Ago\', b\' minutes ago.\')]))]\\n\\n    service_children_cron_job = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'UNameSpace1\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'UNameSpace2\', b\' \'), DelimitedDataModelElement(\'User\', b\' \'),\\n        FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Details\', b\']: Job `cron.daily` started.\')]\\n\\n    service_children_random_time = [FixedDataModelElement(\'Space\', b\'Random: \'), DecimalIntegerValueModelElement(\'Random\')]\\n\\n    service_children_sensors = [SequenceModelElement(\'CPUTemp\', [\\n        FixedDataModelElement(\'FixedTemp\', b\'CPU Temp: \'), DecimalIntegerValueModelElement(\'Temp\'),\\n        FixedDataModelElement(\'Degrees\', b\'\\\\xc2\\\\xb0C\')]), FixedDataModelElement(\'Space1\', b\', \'), SequenceModelElement(\'CPUWorkload\', [\\n            FixedDataModelElement(\'FixedWorkload\', b\'CPUWorkload: \'), DecimalIntegerValueModelElement(\'Workload\'),\\n            FixedDataModelElement(\'Percent\', b\'%\')]), FixedDataModelElement(\'Space2\', b\', \'),\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\')]\\n\\n    service_children_user_ip_address = [\\n        FixedDataModelElement(\'User\', b\'User \'), DelimitedDataModelElement(\'Username\', b\' \'),\\n        FixedDataModelElement(\'Action\', b\' changed IP address to \'), IpAddressDataModelElement(\'IP\')]\\n\\n    service_children_cron_job_announcement = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'Space\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Run\', b\']: Will run job `\'),\\n        FixedWordlistDataModelElement(\'CronType\', [b\'cron.daily\', b\'cron.hourly\', b\'cron.monthly\', b\'cron.weekly\']),\\n        FixedDataModelElement(\'StartTime\', b\'\\\\\' in 5 min.\')]\\n\\n    service_children_cron_job_execution = [\\n        DateTimeModelElement(\'DTM\', b\'%Y-%m-%d %H:%M:%S\'), FixedDataModelElement(\'Space1\', b\' \'),\\n        DelimitedDataModelElement(\'UName\', b\' \'), FixedDataModelElement(\'Cron\', b\' cron[\'), DecimalIntegerValueModelElement(\'JobNumber\'),\\n        FixedDataModelElement(\'Job\', b\']: Job `\'),\\n        FixedWordlistDataModelElement(\'CronType\', [b\'cron.daily\', b\'cron.hourly\', b\'cron.monthly\', b\'cron.weekly\']),\\n        FixedDataModelElement(\'Started\', b\'\\\\\' started\')]\\n\\n    parsing_model = FirstMatchModelElement(\'model\', [\\n        SequenceModelElement(\'CronAnnouncement\', service_children_cron_job_announcement),\\n        SequenceModelElement(\'CronExecution\', service_children_cron_job_execution),\\n        SequenceModelElement(\'DailyCron\', service_children_cron_job), SequenceModelElement(\'DiskReport\', service_children_disk_report),\\n        SequenceModelElement(\'LoginDetails\', service_children_login_details), DecimalIntegerValueModelElement(\'Random\'),\\n        SequenceModelElement(\'RandomTime\', service_children_random_time), SequenceModelElement(\'Sensors\', service_children_sensors),\\n        SequenceModelElement(\'IPAddresses\', service_children_user_ip_address)])\\n\\n    # Some generic imports.\\n    from aminer.analysis import AtomFilters\\n\\n    # Create all global handler lists here and append the real handlers later on.\\n    # Use this filter to distribute all atoms to the analysis handlers.\\n    atom_filters = AtomFilters.SubhandlerFilter(None)\\n    analysis_context.register_component(atom_filters, component_name=\\"AtomFilter\\")\\n\\n    from aminer.analysis.TimestampCorrectionFilters import SimpleMonotonicTimestampAdjust\\n    simple_monotonic_timestamp_adjust = SimpleMonotonicTimestampAdjust([atom_filters])\\n    analysis_context.register_component(simple_monotonic_timestamp_adjust, component_name=\\"SimpleMonotonicTimestampAdjust\\")\\n\\n    from aminer.events.StreamPrinterEventHandler import StreamPrinterEventHandler\\n    import os\\n    import stat\\n    stpe = StreamPrinterEventHandler(analysis_context)\\n    aminer_rest_output = "/tmp/aminer-rest-output.log"\\n    mode = \'w+\'\\n    if os.path.exists(aminer_rest_output) and stat.S_ISFIFO(os.stat(aminer_rest_output).st_mode):\\n        mode = \'w\'\\n    stream = open(aminer_rest_output, mode)\\n    aminer_rest_stpe = StreamPrinterEventHandler(analysis_context, stream)\\n    from aminer.events.JsonConverterHandler import JsonConverterHandler\\n    aminer_rest_jch = JsonConverterHandler([aminer_rest_stpe], analysis_context, pretty_print=False)\\n\\n    from aminer.events.Utils import VolatileLogarithmicBackoffEventHistory\\n    volatile_logarithmic_backoff_event_history = VolatileLogarithmicBackoffEventHistory(100)\\n    anomaly_event_handlers = [stpe, aminer_rest_jch, volatile_logarithmic_backoff_event_history]\\n    analysis_context.register_component(volatile_logarithmic_backoff_event_history, component_name=\\"VolatileLogarithmicBackoffEventHistory\\")\\n\\n    # Now define the AtomizerFactory using the model. A simple line based one is usually sufficient.\\n    from aminer.input.SimpleByteStreamLineAtomizerFactory import SimpleByteStreamLineAtomizerFactory\\n    analysis_context.atomizer_factory = SimpleByteStreamLineAtomizerFactory(\\n        parsing_model, [simple_monotonic_timestamp_adjust], anomaly_event_handlers, use_real_time=True)\\n\\n    # Just report all unparsed atoms to the event handlers.\\n    from aminer.analysis.UnparsedAtomHandlers import SimpleUnparsedAtomHandler\\n    simple_unparsed_atom_handler = SimpleUnparsedAtomHandler(anomaly_event_handlers)\\n    atom_filters.add_handler(simple_unparsed_atom_handler, stop_when_handled_flag=True)\\n    analysis_context.register_component(simple_unparsed_atom_handler, component_name=\\"UnparsedHandler\\")\\n\\n    from aminer.analysis.TimestampsUnsortedDetector import TimestampsUnsortedDetector\\n    timestamps_unsorted_detector = TimestampsUnsortedDetector(analysis_context.aminer_config, anomaly_event_handlers)\\n    atom_filters.add_handler(timestamps_unsorted_detector)\\n    analysis_context.register_component(timestamps_unsorted_detector, component_name=\\"TimestampsUnsortedDetector\\")\\n\\n    from aminer.analysis import Rules\\n    from aminer.analysis.AllowlistViolationDetector import AllowlistViolationDetector\\n    allowlist_rules = [\\n        Rules.OrMatchRule([\\n            Rules.AndMatchRule([\\n                Rules.PathExistsMatchRule(\'/model/LoginDetails/PastTime/Time/Minutes\'),\\n                Rules.NegationMatchRule(Rules.ValueMatchRule(\'/model/LoginDetails/Username\', b\'root\'))]),\\n            Rules.AndMatchRule([\\n                Rules.NegationMatchRule(Rules.PathExistsMatchRule(\'/model/LoginDetails/PastTime/Time/Minutes\')),\\n                Rules.PathExistsMatchRule(\'/model/LoginDetails\')]),\\n            Rules.NegationMatchRule(Rules.PathExistsMatchRule(\'/model/LoginDetails\'))])]\\n\\n    # This rule list should trigger, when the line does not look like: User root (logged in, logged out)\\n    # or User \'username\' (logged in, logged out) x minutes ago.\\n    allowlist_violation_detector = AllowlistViolationDetector(analysis_context.aminer_config, allowlist_rules, anomaly_event_handlers)\\n    analysis_context.register_component(allowlist_violation_detector, component_name=\\"Allowlist\\")\\n    atom_filters.add_handler(allowlist_violation_detector)\\n\\n    from aminer.analysis.ParserCount import ParserCount\\n    parser_count = ParserCount(analysis_context.aminer_config, None, anomaly_event_handlers, 10)\\n    analysis_context.register_component(parser_count, component_name=\\"ParserCount\\")\\n    atom_filters.add_handler(parser_count)\\n\\n    from aminer.analysis.EventCorrelationDetector import EventCorrelationDetector\\n    ecd = EventCorrelationDetector(analysis_context.aminer_config, anomaly_event_handlers, check_rules_flag=True,\\n                                   hypothesis_max_delta_time=1.0, learn_mode=True)\\n    analysis_context.register_component(ecd, component_name=\\"EventCorrelationDetector\\")\\n    atom_filters.add_handler(ecd)\\n\\n    from aminer.analysis.NewMatchPathDetector import NewMatchPathDetector\\n    new_match_path_detector = NewMatchPathDetector(analysis_context.aminer_config, anomaly_event_handlers, learn_mode=True)\\n    analysis_context.register_component(new_match_path_detector, component_name=\\"NewMatchPath\\")\\n    atom_filters.add_handler(new_match_path_detector)\\n\\n    def tuple_transformation_function(match_value_list):\\n        \\"\\"\\"Only allow output of the EnhancedNewMatchPathValueComboDetector\\n        after every 10000th element.\\"\\"\\"\\n        extra_data = enhanced_new_match_path_value_combo_detector.known_values_dict.get(tuple(match_value_list))\\n        if extra_data is not None:\\n            mod = 10000\\n            if (extra_data[2] + 1) % mod == 0:\\n                enhanced_new_match_path_value_combo_detector.learn_mode = False\\n            else:\\n                enhanced_new_match_path_value_combo_detector.learn_mode = True\\n        return match_value_list\\n\\n    from aminer.analysis.EnhancedNewMatchPathValueComboDetector import EnhancedNewMatchPathValueComboDetector\\n    enhanced_new_match_path_value_combo_detector = EnhancedNewMatchPathValueComboDetector(\\n        analysis_context.aminer_config, [\'/model/DailyCron/UName\', \'/model/DailyCron/JobNumber\'], anomaly_event_handlers,\\n        learn_mode=False, tuple_transformation_function=tuple_transformation_function)\\n    analysis_context.register_component(enhanced_new_match_path_value_combo_detector, component_name=\\"EnhancedNewValueCombo\\")\\n    atom_filters.add_handler(enhanced_new_match_path_value_combo_detector)\\n\\n    from aminer.analysis.HistogramAnalysis import HistogramAnalysis, LinearNumericBinDefinition, ModuloTimeBinDefinition, \\\\\\n        PathDependentHistogramAnalysis\\n    modulo_time_bin_definition = ModuloTimeBinDefinition(86400, 3600, 0, 1, 24, True)\\n    linear_numeric_bin_definition = LinearNumericBinDefinition(50, 5, 20, True)\\n    histogram_analysis = HistogramAnalysis(analysis_context.aminer_config, [\\n        (\'/model/RandomTime/Random\', modulo_time_bin_definition), (\'/model/Random\', linear_numeric_bin_definition)], 10,\\n        anomaly_event_handlers)\\n    analysis_context.register_component(histogram_analysis, component_name=\\"HistogramAnalysis\\")\\n    atom_filters.add_handler(histogram_analysis)\\n\\n    path_dependent_histogram_analysis = PathDependentHistogramAnalysis(analysis_context.aminer_config, \'/model/RandomTime\',\\n                                                                       modulo_time_bin_definition, 10, anomaly_event_handlers)\\n    analysis_context.register_component(path_dependent_histogram_analysis, component_name=\\"PathDependentHistogramAnalysis\\")\\n    atom_filters.add_handler(path_dependent_histogram_analysis)\\n\\n    from aminer.analysis.MatchValueAverageChangeDetector import MatchValueAverageChangeDetector\\n    match_value_average_change_detector = MatchValueAverageChangeDetector(analysis_context.aminer_config, anomaly_event_handlers, None,\\n                                                                          [\'/model/Random\'], 100, 10)\\n    analysis_context.register_component(match_value_average_change_detector, component_name=\\"MatchValueAverageChange\\")\\n    atom_filters.add_handler(match_value_average_change_detector)\\n\\n    import sys\\n    from aminer.analysis.MatchValueStreamWriter import MatchValueStreamWriter\\n    match_value_stream_writer = MatchValueStreamWriter(\\n        sys.stdout, [\'/model/Sensors/CPUTemp\', \'/model/Sensors/CPUWorkload\', \'/model/Sensors/DTM\'], b\';\', b\'\')\\n    analysis_context.register_component(match_value_stream_writer, component_name=\\"MatchValueStreamWriter\\")\\n    atom_filters.add_handler(match_value_stream_writer)\\n\\n    from aminer.analysis.NewMatchPathValueComboDetector import NewMatchPathValueComboDetector\\n    new_match_path_value_combo_detector = NewMatchPathValueComboDetector(analysis_context.aminer_config, [\\n        \'/model/IPAddresses/Username\', \'/model/IPAddresses/IP\'], anomaly_event_handlers, learn_mode=False)\\n    analysis_context.register_component(new_match_path_value_combo_detector, component_name=\\"NewMatchPathValueCombo\\")\\n    atom_filters.add_handler(new_match_path_value_combo_detector)\\n\\n    from aminer.analysis.NewMatchIdValueComboDetector import NewMatchIdValueComboDetector\\n    new_match_id_value_combo_detector = NewMatchIdValueComboDetector(\\n        analysis_context.aminer_config, [\'/model/type/path/id\', \'/model/type/syscall/id\'], anomaly_event_handlers,\\n        id_path_list=[\'/model/type/path/id\', \'/model/type/syscall/id\'], min_allowed_time_diff=5, learn_mode=True,\\n        allow_missing_values_flag=True, output_logline=True)\\n    analysis_context.register_component(new_match_id_value_combo_detector, component_name=\\"NewMatchIdValueComboDetector\\")\\n    atom_filters.add_handler(new_match_id_value_combo_detector)\\n\\n    from aminer.analysis.NewMatchPathValueDetector import NewMatchPathValueDetector\\n    new_match_path_value_detector = NewMatchPathValueDetector(analysis_context.aminer_config, [\\n        \'/model/DailyCron/Job Number\', \'/model/IPAddresses/Username\'], anomaly_event_handlers, learn_mode=False)\\n    analysis_context.register_component(new_match_path_value_detector, component_name=\\"NewMatchPathValue\\")\\n    atom_filters.add_handler(new_match_path_value_detector)\\n\\n    from aminer.analysis.MissingMatchPathValueDetector import MissingMatchPathValueDetector\\n    missing_match_path_value_detector = MissingMatchPathValueDetector(\\n        analysis_context.aminer_config, [\'/model/DiskReport/Space\'], anomaly_event_handlers, learn_mode=False, default_interval=2,\\n        realert_interval=5)\\n    analysis_context.register_component(missing_match_path_value_detector, component_name=\\"MissingMatch\\")\\n    atom_filters.add_handler(missing_match_path_value_detector)\\n\\n    from aminer.analysis.TimeCorrelationDetector import TimeCorrelationDetector\\n    time_correlation_detector = TimeCorrelationDetector(\\n        analysis_context.aminer_config, anomaly_event_handlers, 2, min_rule_attributes=1, max_rule_attributes=5,\\n        record_count_before_event=70000, output_logline=True)\\n    analysis_context.register_component(time_correlation_detector, component_name=\\"TimeCorrelationDetector\\")\\n    atom_filters.add_handler(time_correlation_detector)\\n\\n    from aminer.analysis.TimeCorrelationViolationDetector import TimeCorrelationViolationDetector, CorrelationRule, EventClassSelector\\n    cron_job_announcement = CorrelationRule(\'CronJobAnnouncement\', 5, 6, artefact_match_parameters=[\\n        (\'/model/CronAnnouncement/JobNumber\', \'/model/CronExecution/JobNumber\')])\\n    a_class_selector = EventClassSelector(\'Announcement\', [cron_job_announcement], None)\\n    b_class_selector = EventClassSelector(\'Execution\', None, [cron_job_announcement])\\n    rules = [Rules.PathExistsMatchRule(\'/model/CronAnnouncement/Run\', a_class_selector),\\n             Rules.PathExistsMatchRule(\'/model/CronExecution/Job\', b_class_selector)]\\n\\n    time_correlation_violation_detector = TimeCorrelationViolationDetector(analysis_context.aminer_config, rules, anomaly_event_handlers)\\n    analysis_context.register_component(time_correlation_violation_detector, component_name=\\"TimeCorrelationViolationDetector\\")\\n    atom_filters.add_handler(time_correlation_violation_detector)\\n\\n    from aminer.events.DefaultMailNotificationEventHandler import DefaultMailNotificationEventHandler\\n    if DefaultMailNotificationEventHandler.CONFIG_KEY_MAIL_TARGET_ADDRESS in analysis_context.aminer_config.config_properties:\\n        mail_notification_handler = DefaultMailNotificationEventHandler(analysis_context)\\n        analysis_context.register_component(mail_notification_handler, component_name=\\"MailHandler\\")\\n        anomaly_event_handlers.append(mail_notification_handler)\\n\\n    setattr(analysis_context.get_component_by_name(\\"NewMatchPathValueCombo\\"), \\"learn_mode\\", False)\\n    component = analysis_context.get_component_by_name(\\"NewMatchPathValueCombo\\")\\n    analysis_context.registered_components_by_name[\\"NewMatchPathValueCombo\\"] = None\\n    analysis_context.registered_components_by_name[\\"NewMatchPathValueComboDetector\\"] = component\\n    component = analysis_context.get_component_by_name(\\"NewMatchPathValueComboDetector\\")\\n    analysis_context.registered_components_by_name[\\"NewMatchPathValueComboDetector\\"] = None\\n    analysis_context.registered_components_by_name[\\"NewMatchPathValueCombo\\"] = component\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600\'"'
        contentyml = b'"Remote execution response: \'LearnMode: False\\n\\nCore.LogDir: \'/tmp/lib/aminer/log\'\\n\\nCore.PersistenceDir: \'/tmp/lib/aminer\'\\n\\nCore.PersistencePeriod: 600\\n\\n# can not use unix socket for aminer-rest, because the socket needs to be open, while aminer-rest needs aminer running at startup.\\nLogResourceList:\\n        - \'file:///tmp/syslog\'\\n        - \'file:///tmp/aminer-rest-input.log\'\\n\\nRemoteControlSocket: \'/var/run/aminer-remote.socket\'\\n\\nMailAlerting.TargetAddress: \'root@localhost\'\\n\\nMailAlerting.FromAddress: \'root@localhost\'\\n\\nMailAlerting.SubjectPrefix: \'aminer Alerts:\'\\n\\nMailAlerting.AlertGraceTime: 0\\n\\nMailAlerting.EventCollectTime: 0\\n\\nMailAlerting.MinAlertGap: 0\\n\\nMailAlerting.MaxAlertGap: 600\\n\\nMailAlerting.MaxEventsPerMessage: 1000\\n\\nLogPrefix: \'Original log line: \'\\n\\nAminerId: \'demo-aminer\'\\n\\nParser:\\n       - id: space\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \' Current Disk Data is: Filesystem     Type  Size  Used Avail Use%\'\\n\\n       - id: data\\n         type: DelimitedDataModelElement\\n         name: \'Data\'\\n         delimiter: \'%\'\'/\'\\n\\n       - id: rest\\n         type: AnyByteDataModelElement\\n         name: \'Rest\'\\n\\n       - id: userLoginDetails\\n         type: FixedDataModelElement\\n         name: \'User\'\\n         args: \'User \'\\n\\n       - id: userIpAddress\\n         type: FixedDataModelElement\\n         name: \'User\'\\n         args: \'User \'\\n\\n       - id: username\\n         type: DelimitedDataModelElement\\n         name: \'Username\'\\n         delimiter: \' \'\\n\\n       - id: status\\n         type: FixedWordlistDataModelElement\\n         name: \'Status\'\\n         args:\\n           - \' logged in\'\\n           - \' logged out\'\\n\\n       - id: blank\\n         type: FixedDataModelElement\\n         name: \'Blank\'\\n         args: \' \'\\n\\n       - id: minutes\\n         type: DecimalIntegerValueModelElement\\n         name: \'Minutes\'\\n\\n       - id: ago\\n         type: FixedDataModelElement\\n         name: \'Ago\'\\n         args: \' minutes ago.\'\\n\\n       - id: time\\n         type: SequenceModelElement\\n         name: \'Time\'\\n         args:\\n           - blank\\n           - minutes\\n           - ago\\n\\n       - id: pastTime\\n         type: OptionalMatchModelElement\\n         name: \'PastTime\'\\n         args: time\\n\\n       - id: dtm\\n         type: DateTimeModelElement\\n         name: \'DTM\'\\n         date_format: \'%Y-%m-%d %H:%M:%S\'\\n         start_year: null\\n         text_locale: null\\n         max_time_jump_seconds: 86400\\n\\n       - id: uNameSpace1\\n         type: FixedDataModelElement\\n         name: \'UNameSpace1\'\\n         args: \' \'\\n\\n       - id: uName\\n         type: DelimitedDataModelElement\\n         name: \'UName\'\\n         delimiter: \' \'\\n\\n       - id: uNameSpace2\\n         type: FixedDataModelElement\\n         name: \'UNameSpace2\'\\n         args: \' \'\\n\\n       - id: delimitedUser\\n         type: DelimitedDataModelElement\\n         name: \'User\'\\n         delimiter: \' \'\\n\\n       - id: cron\\n         type: FixedDataModelElement\\n         name: \'Cron\'\\n         args: \' cron[\'\\n\\n       - id: jobNumber\\n         type: DecimalIntegerValueModelElement\\n         name: \'JobNumber\'\\n\\n       - id: details\\n         type: FixedDataModelElement\\n         name: \'Details\'\\n         args: \']: Job `cron.daily` started.\'\\n\\n       - id: spaceRandom\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \'Random: \'\\n\\n       - id: random\\n         type: DecimalIntegerValueModelElement\\n         name: \'Random\'\\n\\n       - id: fixedTemp\\n         type: FixedDataModelElement\\n         name: \'FixedTemp\'\\n         args: \'CPU Temp: \'\\n\\n       - id: temp\\n         type: DecimalIntegerValueModelElement\\n         name: \'Temp\'\\n\\n       - id: degrees\\n         type: FixedDataModelElement\\n         name: \'Degrees\'\\n         args: \'\xc2\xb0C\'\\n\\n       - id: cpuTemp\\n         type: SequenceModelElement\\n         name: \'CPUTemp\'\\n         args:\\n           - fixedTemp\\n           - temp\\n           - degrees\\n\\n       - id: space1\\n         type: FixedDataModelElement\\n         name: \'Space1\'\\n         args: \', \'\\n\\n       - id: fixedWorkload\\n         type: FixedDataModelElement\\n         name: \'FixedWorkload\'\\n         args: \'CPU Workload: \'\\n\\n       - id: workload\\n         type: DecimalIntegerValueModelElement\\n         name: \'Workload\'\\n\\n       - id: percent\\n         type: FixedDataModelElement\\n         name: \'Percent\'\\n         args: \'%\'\\n\\n       - id: cpuWorkload\\n         type: SequenceModelElement\\n         name: \'CPUWorkload\'\\n         args:\\n           - fixedWorkload\\n           - workload\\n           - percent\\n\\n       - id: space2\\n         type: FixedDataModelElement\\n         name: \'Space2\'\\n         args: \', \'\\n\\n       - id: action\\n         type: FixedDataModelElement\\n         name: \'Action\'\\n         args: \' changed IP address to \'\\n\\n       - id: ip\\n         type: IpAddressDataModelElement\\n         name: \'IP\'\\n\\n       - id: fixedSpace\\n         type: FixedDataModelElement\\n         name: \'Space\'\\n         args: \' \'\\n\\n       - id: run\\n         type: FixedDataModelElement\\n         name: \'Run\'\\n         args: \']: Will run job `\'\\n\\n       - id: cronType\\n         type: FixedWordlistDataModelElement\\n         name: \'CronType\'\\n         args:\\n           - \'cron.daily\'\\n           - \'cron.hourly\'\\n           - \'cron.monthly\'\\n           - \'cron.weekly\'\\n\\n       - id: startTime\\n         type: FixedDataModelElement\\n         name: \'StartTime\'\\n         args: \\"\' in 5 min.\\"\\n\\n       - id: emptySpace1\\n         type: FixedDataModelElement\\n         name: \'Space1\'\\n         args: \' \'\\n\\n       - id: job\\n         type: FixedDataModelElement\\n         name: \'Job\'\\n         args: \']: Job `\'\\n\\n       - id: started\\n         type: FixedDataModelElement\\n         name: \'Started\'\\n         args: \\"\' started\\"\\n\\n       - id: cronAnnouncement\\n         type: SequenceModelElement\\n         name: \'CronAnnouncement\'\\n         args:\\n           - dtm\\n           - fixedSpace\\n           - uName\\n           - cron\\n           - jobNumber\\n           - run\\n           - cronType\\n           - startTime\\n\\n       - id: cronExecution\\n         type: SequenceModelElement\\n         name: \'CronExecution\'\\n         args:\\n           - dtm\\n           - emptySpace1\\n           - uName\\n           - cron\\n           - jobNumber\\n           - job\\n           - cronType\\n           - started\\n\\n       - id: dailyCron\\n         type: SequenceModelElement\\n         name: \'DailyCron\'\\n         args:\\n           - dtm\\n           - uNameSpace1\\n           - uName\\n           - uNameSpace2\\n           - delimitedUser\\n           - cron\\n           - jobNumber\\n           - details\\n\\n       - id: diskReport\\n         type: SequenceModelElement\\n         name: \'DiskReport\'\\n         args:\\n           - space\\n           - data\\n           - rest\\n\\n       - id: loginDetails\\n         type: SequenceModelElement\\n         name: \'LoginDetails\'\\n         args:\\n           - userLoginDetails\\n           - username\\n           - status\\n           - pastTime\\n\\n       - id: randomTime\\n         type: SequenceModelElement\\n         name: \'RandomTime\'\\n         args:\\n           - spaceRandom\\n           - random\\n\\n       - id: sensors\\n         type: SequenceModelElement\\n         name: \'Sensors\'\\n         args:\\n           - cpuTemp\\n           - space1\\n           - cpuWorkload\\n           - space2\\n           - dtm\\n\\n       - id: ipAddresses\\n         type: SequenceModelElement\\n         name: \'IPAddresses\'\\n         args:\\n           - userIpAddress\\n           - username\\n           - action\\n           - ip\\n\\n       - id: model\\n         start: True\\n         type: FirstMatchModelElement\\n         name: \'model\'\\n         args:\\n           - cronAnnouncement\\n           - cronExecution\\n           - dailyCron\\n           - diskReport\\n           - loginDetails\\n           - random\\n           - randomTime\\n           - sensors\\n           - ipAddresses\\n\\nInput:\\n        timestamp_paths: [\\"/model/DailyCron/DTM\\"]\\n        adjust_timestamps: True\\n        use_real_time: True\\n\\nAnalysis:\\n        - type: TimestampsUnsortedDetector\\n          id: TimestampsUnsortedDetector\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule1\\n          path: \\"/model/LoginDetails/PastTime/Time/Minutes\\"\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule2\\n          path: \\"/model/LoginDetails\\"\\n        - type: ValueMatchRule\\n          id: value_match_rule\\n          path: \\"/model/LoginDetails/Username\\"\\n          value: \\"root\\"\\n        - type: NegationMatchRule\\n          id: negation_match_rule1\\n          sub_rule: \\"value_match_rule\\"\\n        - type: NegationMatchRule\\n          id: negation_match_rule2\\n          sub_rule: \\"path_exists_match_rule2\\"\\n        - type: AndMatchRule\\n          id: and_match_rule1\\n          sub_rules:\\n            - \\"path_exists_match_rule1\\"\\n            - \\"negation_match_rule1\\"\\n        - type: AndMatchRule\\n          id: and_match_rule2\\n          sub_rules:\\n            - \\"negation_match_rule1\\"\\n            - \\"path_exists_match_rule2\\"\\n        - type: OrMatchRule\\n          id: or_match_rule\\n          sub_rules:\\n            - \\"and_match_rule1\\"\\n            - \\"and_match_rule2\\"\\n            - \\"negation_match_rule2\\"\\n        - type: AllowlistViolationDetector\\n          id: Allowlist\\n          allowlist_rules:\\n            - \\"or_match_rule\\"\\n        - type: ParserCount\\n          id: ParserCount\\n          report_interval: 10\\n        - type: MatchFilter\\n          id: MatchFilter\\n          paths:\\n            - \\"/model/Random\\"\\n          value_list:\\n            - 1\\n            - 10\\n            - 100\\n        - type: EnhancedNewMatchPathValueComboDetector\\n          id: EnhancedNewValueCombo\\n          paths:\\n            - \\"/model/DailyCron/UName\\"\\n            - \\"/model/DailyCron/JobNumber\\"\\n          tuple_transformation_function: \\"demo\\"\\n          learn_mode: True\\n        - type: ModuloTimeMatchRule\\n          id: \\"mt\\"\\n          path: \\"mtmr\\"\\n          seconds_modulo: 3\\n          lower_limit: 0\\n          upper_limit: 3\\n        - type: ValueDependentModuloTimeMatchRule\\n          id: \\"vdmt\\"\\n          path: \\"vdmtmr\\"\\n          seconds_modulo: 3\\n          paths:\\n            - \\"/model/ECD/g\\"\\n            - \\"/model/ECD/h\\"\\n            - \\"/model/ECD/i\\"\\n            - \\"/model/ECD/j\\"\\n            - \\"/model/ECD/k\\"\\n            - \\"/model/ECD/l\\"\\n          limit_lookup_dict:\\n            e:\\n              - 0\\n              - 2.95\\n          default_limit:\\n            - 0\\n            - 3\\n        - type: ValueDependentDelegatedMatchRule\\n          id: \\"value_dependent_delegated_match_rule\\"\\n          paths:\\n            - \\"/model/ECD/g\\"\\n            - \\"/model/ECD/h\\"\\n            - \\"/model/ECD/i\\"\\n            - \\"/model/ECD/j\\"\\n            - \\"/model/ECD/k\\"\\n            - \\"/model/ECD/l\\"\\n          rule_lookup_dict:\\n            (b\\"g\\",): \\"mt\\"\\n            (b\\"h\\",): \\"mt\\"\\n            (b\\"i\\",): \\"mt\\"\\n            (b\\"j\\",): \\"vdmt\\"\\n            (b\\"k\\",): \\"vdmt\\"\\n            (b\\"l\\",): \\"vdmt\\"\\n          default_rule: \\"mt\\"\\n        - type: EventGenerationMatchAction\\n          id: \\"ip_match_action\\"\\n          event_type: \\"Analysis.Rules.IPv4InRFC1918MatchRule\\"\\n          event_message: \\"Private IP address occurred!\\"\\n        - type: IPv4InRFC1918MatchRule\\n          id: \\"ipv4_in_rfc1918_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          match_action: \\"ip_match_action\\"\\n        - type: DebugHistoryMatchRule\\n          id: \\"debug_history_match_rule\\"\\n          debug_mode: True\\n        - type: ValueListMatchRule\\n          id: \\"value_list_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          value_list:\\n            - 134744072\\n            - 134743044\\n        - type: NegationMatchRule\\n          id: \\"negation_list\\"\\n          sub_rule: \\"value_list_match_rule\\"\\n        - type: ValueRangeMatchRule\\n          id: \\"value_range_match_rule\\"\\n          path: \\"/model/ParsingME/se2/IpAddressDataModelElement\\"\\n          lower_limit: 167772160\\n          upper_limit: 184549375\\n        - type: NegationMatchRule\\n          id: \\"negation_range\\"\\n          sub_rule: \\"value_range_match_rule\\"\\n        - type: StringRegexMatchRule\\n          id: \\"string_regex_match_rule\\"\\n          path: \\"/model/type/syscall/success\\"\\n          regex: \\"^no$\\"\\n        - type: NegationMatchRule\\n          id: \\"negation_string_regex\\"\\n          sub_rule: \\"string_regex_match_rule\\"\\n        - type: ParallelMatchRule\\n          id: \\"parallel_match_rule\\"\\n          sub_rules:\\n            - \\"value_dependent_delegated_match_rule\\"\\n            - \\"ipv4_in_rfc1918_match_rule\\"\\n            - \\"debug_history_match_rule\\"\\n        - type: AndMatchRule\\n          id: \\"time_and_match_rule\\"\\n          sub_rules:\\n            - \\"parallel_match_rule\\"\\n            - \\"negation_list\\"\\n            - \\"negation_range\\"\\n            - \\"negation_string_regex\\"\\n        - type: AllowlistViolationDetector\\n          id: TimeAllowlist\\n          allowlist_rules:\\n            - \\"time_and_match_rule\\"\\n        - type: LinearNumericBinDefinition\\n          id: linear_numeric_bin_definition\\n          lower_limit: 50\\n          bin_size: 5\\n          bin_count: 20\\n          outlier_bins_flag: True\\n        - type: ModuloTimeBinDefinition\\n          id: modulo_time_bin_definition\\n          modulo_value: 86400\\n          time_unit: 3600\\n          lower_limit: 0\\n          bin_size: 1\\n          bin_count: 24\\n          outlier_bins_flag: True\\n        - type: HistogramAnalysis\\n          id: HistogramAnalysis\\n          histogram_defs: [[\\"/model/RandomTime/Random\\", \\"linear_numeric_bin_definition\\"]]\\n          report_interval: 10\\n        - type: PathDependentHistogramAnalysis\\n          id: PathDependentHistogramAnalysis\\n          path: \\"/model/RandomTime\\"\\n          bin_definition: \\"modulo_time_bin_definition\\"\\n          report_interval: 10\\n        - type: MatchValueAverageChangeDetector\\n          id: MatchValueAverageChange\\n          timestamp_path: null\\n          paths:\\n            - \\"/model/Random\\"\\n          min_bin_elements: 100\\n          min_bin_time: 10\\n        - type: MatchValueStreamWriter\\n          id: MatchValueStreamWriter\\n          stream: \\"sys.stdout\\"\\n          paths:\\n            - \\"/model/Sensors/CPUTemp\\"\\n            - \\"/model/Sensors/CPUWorkload\\"\\n            - \\"/model/Sensors/DTM\\"\\n          separator: \\";\\"\\n          missing_value_string: \\"\\"\\n        - type: NewMatchPathValueComboDetector\\n          id: NewMatchPathValueCombo\\n          paths:\\n            - \\"/model/IPAddresses/Username\\"\\n            - \\"/model/IPAddresses/IP\\"\\n          learn_mode: False\\n          log_resource_ignore_list:\\n            - \'file:///tmp/other_syslog\'\\n        - type: NewMatchIdValueComboDetector\\n          id: NewMatchIdValueComboDetector\\n          paths:\\n            - \\"/model/type/path/name\\"\\n            - \\"/model/type/syscall/syscall\\"\\n          id_path_list:\\n            - \\"/model/type/path/id\\"\\n            - \\"/model/type/syscall/id\\"\\n          min_allowed_time_diff: 5\\n          allow_missing_values: True\\n          learn_mode: True\\n        - type: NewMatchPathValueDetector\\n          id: NewMatchPathValue\\n          paths:\\n            - \\"/model/DailyCron/JobNumber\\"\\n            - \\"/model/IPAddresses/Username\\"\\n          learn_mode: True\\n        - type: MissingMatchPathValueDetector\\n          id: MissingMatch\\n          paths:\\n            - \\"/model/DiskReport/Space\\"\\n          check_interval: 2\\n          realert_interval: 5\\n          learn_mode: True\\n        - type: TimeCorrelationDetector\\n          id: TimeCorrelationDetector\\n          parallel_check_count: 2\\n          min_rule_attributes: 1\\n          max_rule_attributes: 5\\n          record_count_before_event: 10000\\n        - type: CorrelationRule\\n          rule_id: correlation_rule\\n          min_time_delta: 5\\n          max_time_delta: 6\\n          artefact_match_parameters: [[\\"/model/CronAnnouncement/JobNumber\\", \\"/model/CronExecution/JobNumber\\"]]\\n        - type: EventClassSelector\\n          action_id: a_class_selector\\n          artefact_a_rules:\\n            - correlation_rule\\n        - type: EventClassSelector\\n          action_id: b_class_selector\\n          artefact_b_rules:\\n            - correlation_rule\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule3\\n          path: \\"/model/CronAnnouncement/Run\\"\\n          match_action: a_class_selector\\n        - type: PathExistsMatchRule\\n          id: path_exists_match_rule4\\n          path: \\"/model/CronExecution/Job\\"\\n          match_action: b_class_selector\\n        - type: TimeCorrelationViolationDetector\\n          id: TimeCorrelationViolationDetector\\n          ruleset:\\n            - path_exists_match_rule3\\n            - path_exists_match_rule4\\n\\nEventHandlers:\\n        - id: stpe\\n          type: StreamPrinterEventHandler\\n\\n        - id: aminer-rest-stpe\\n          type: StreamPrinterEventHandler\\n          json: True\\n          output_file_path: /tmp/aminer-rest-output.log\\n\'"'
        atom_handler = "AtomFilter"
        class_name = "NewMatchPathDetector"
        parameters = ["analysis_context.aminer_config", "analysis_context.atomizer_factory.event_handler_list", "learn_mode=True"]
        component_name = "NewComponent1"
        response = self.client.post(ANALYSIS_COMPONENT_PATH + atom_handler, json={
            "class_name": class_name, "parameters": parameters, "component_name": component_name}, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f"{{\"message\":\"Successfully added new {class_name} with the name {component_name} to the atom filter {atom_handler}\"}}".encode())
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        c = contentpy.replace(b'\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600\'"', f"\n    add_handler_to_atom_filter_and_register_analysis_component(analysis_context,\\\"AtomFilter\\\",NewMatchPathDetector(analysis_context.aminer_config,analysis_context.atomizer_factory.event_handler_list,learn_mode=True),\\\"NewComponent1\\\")\nconfig_properties[\\\"Core.PersistencePeriod\\\"] = 600".encode() + b'\'"')
        if self.dest_config_file.endswith(".yml"):
            c = contentyml.replace(b'Analysis:\\n        - type: TimestampsUnsortedDetector', b'Analysis:\\n        - type: NewMatchPathDetector\\n          id: NewComponent1\\n          learn_mode: True\\n        - type: TimestampsUnsortedDetector')
        self.assertEqual(new_live_config, c.decode("unicode-escape"))

        atom_handler = "AtomFilter"
        class_name = "MatchValueAverageChangeDetector"
        parameters = ["analysis_context.aminer_config", "analysis_context.atomizer_factory.event_handler_list", "\"/some/timestamp/path\"", "[\"some/target/path\"]", "1", "10", "learn_mode=True"]
        component_name = "MatchValueAverageChange-NEW"
        response = self.client.post(ANALYSIS_COMPONENT_PATH + atom_handler, json={
            "class_name": class_name, "parameters": parameters, "component_name": component_name}, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f"{{\"message\":\"Successfully added new {class_name} with the name {component_name} to the atom filter {atom_handler}\"}}".encode())
        new_live_config = self.client.get("/", headers=self.authorization_headers).content.decode("unicode-escape")
        c = contentpy.replace(b'\\nconfig_properties[\\"Core.PersistencePeriod\\"] = 600\'"', f"\n    add_handler_to_atom_filter_and_register_analysis_component(analysis_context,\\\"AtomFilter\\\",NewMatchPathDetector(analysis_context.aminer_config,analysis_context.atomizer_factory.event_handler_list,learn_mode=True),\\\"NewComponent1\\\")\n    add_handler_to_atom_filter_and_register_analysis_component(analysis_context,\\\"AtomFilter\\\",MatchValueAverageChangeDetector(analysis_context.aminer_config,analysis_context.atomizer_factory.event_handler_list,\\\"/some/timestamp/path\\\",[\\\"some/target/path\\\"],1,10,learn_mode=True),\\\"MatchValueAverageChange-NEW\\\")\nconfig_properties[\\\"Core.PersistencePeriod\\\"] = 600".encode() + b'\'"')
        if self.dest_config_file.endswith(".yml"):
            c = contentyml.replace(b'Analysis:\\n        - type: TimestampsUnsortedDetector', b'Analysis:\\n        - type: MatchValueAverageChangeDetector\\n          id: MatchValueAverageChange-NEW\\n          timestamp_path: "/some/timestamp/path"\\n          paths: ["some/target/path"]\\n          min_bin_elements: 1\\n          min_bin_time: 10\\n          learn_mode: True\\n        - type: NewMatchPathDetector\\n          id: NewComponent1\\n          learn_mode: True\\n        - type: TimestampsUnsortedDetector')
        self.assertEqual(new_live_config, c.decode("unicode-escape"))

        response = self.client.post(ANALYSIS_COMPONENT_PATH + atom_handler, json={
            "class_name": class_name, "parameters": parameters, "component_name": component_name})
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")

        response = self.client.post(ANALYSIS_COMPONENT_PATH + atom_handler, json={
            "class_name": class_name, "parameters": parameters, "component_name": component_name}, headers={
            "Authorization": "%s %s" % (self.token_type, self.access_token + "failedtoken")})
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")

        atom_handler = "UnknownAtomFilter"
        response = self.client.post(ANALYSIS_COMPONENT_PATH + atom_handler, json={
            "class_name": class_name, "parameters": parameters, "component_name": component_name}, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 404)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f'{{"detail":"atom_handler \'{atom_handler}\' does not exist!"}}'.encode())

        atom_handler = "AtomFilter"
        response = self.client.post(ANALYSIS_COMPONENT_PATH + atom_handler, json={
            "class_name": class_name, "parameters": parameters, "component_name": component_name}, headers=self.authorization_headers)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.headers["content-type"], "application/json")
        self.assertEqual(response.content, f'{{"detail":"component with same name already registered! ({component_name})"}}'.encode())

    def test8get_current_config(self):
        """This test case checks if the get_current_config method is working
        and if the authorization works as well."""
        response = self.client.get("/", headers=self.authorization_headers)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers["content-type"], "application/json")

        response = self.client.get("/")
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")

        response = self.client.get("/", headers={"Authorization": "%s %s" % (self.token_type, self.access_token + "failedtoken")})
        self.assertEqual(response.status_code, 401)
        self.assertEqual(response.headers["content-type"], "application/json")
